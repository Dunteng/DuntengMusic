# 云开发全栈音乐社区

## 0.概述

<https://juejin.im/post/5d54bbaf518825219c282370>

## 1.课程导学









## 2.项目准备

### 项目初始化

#### 开通云开发服务

点击开发者工具中的云开发即可。

```js
//app.js
App({
  onLaunch: function () {
    
    if (!wx.cloud) {
      console.error('请使用 2.2.3 或以上的基础库以使用云能力')
    } else {
      wx.cloud.init({
        // env 参数说明：
        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源
        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看
        //   如不填则使用默认环境（第一个创建的环境）
        env: 'dev-r049g',
        traceUser: true,  //记录小程序的访问者
      })
    }

    this.globalData = {}  //全局属性和方法
  }
})
```



#### tabbar

![](https://pic1.zhimg.com/v2-19deb38ccb7b019595ce00ab8c608ee8_r.jpg)



## 3.播放列表实现

```
- 组件化开发思想
- 定时触发云函数读取数据并写入云数据库
- 突破云函数读取数据条数限制
- 云函数路由优化tcb-router和洋葱模型
```

 ### 首页轮播图

```js
<swiper indicator-dots="true" autoplay="true" interval="2000" duration="1000" circular="true">
  <block wx:for="{{swiperImgUrls}}">
    <swiper-item>
      <image src="{{item.url}}" mode="widthFix" class="img"></image>
    </swiper-item>
  </block>
</swiper>
```

### 组件化开发思想

#### 概述：

组件：👉在用户界面开发领域，组件是一种面向用户的、独立的、可复用的交互元素的封装。

在小程序的组件化开发中，包括四个部分：【wxml结构】【js逻辑】【wxss样式】【json配置】。

#### 组件化开发的意义：

- 组件化是对实现的分层，是更有效的代码组合方式
- 组件化是对资源的重组和优化，从而使项目资源管理更合理。
- 组件化开发粒度更小，更利于优化维护，利于单元测试。
- 方便重构

#### 设计原则

- 高内聚
- 低耦合
- 单一职责
- 避免过多参数： 组件一般是可配置的，比如小程序自带的swiper组件里面的很多属性都是可配置的。但是我们需要认识到，组件的可配置参数不宜过多，且要做好默认值的配置，否则友好度很低。

#### 本项目封装的组件

- 歌单组件
- 歌曲组件
- 歌曲进度条组件
- 歌词组件
- 动态卡片组件
- 动态控制组件
- 底部弹窗组件
- 登录组件
- 搜索组件





### 歌单组件实现

【/components/playlist/】编写组件实现，通过【/pages/playlist/playlist.json 】进行组件引入。在首页通过父组件添加属性传值给歌单组件。



一个细节，在歌单组件中的文本介绍部分只显示两行且多余的部分用省略号表示👇

![](https://pic4.zhimg.com/80/v2-77212831d8a8c46a67e9dbe808ce8e1f_hd.jpg)

```css
.playlist-name{
  font-size: 26rpx;
  line-height: 1.2;
  padding: 2px 0 0 6px;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp:2;
  overflow: hidden;
  text-overflow: ellipsis;
}
```



另一个细节是要处理播放次数，将其格式化，这里用到了[**数据监听器observers**](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html)

```js
  observers:{
    // 监听playlistItem里的playCount属性，这样下面这种写法
    ['playlistItem.playCount'](count){
      // console.log(count)
      //格式化数据，保留小数点后两位
      // console.log(this._tranNumber(count, 2))
      this.setData({
        _count: this._tranNumber(count,2)  
        //用data中的_count来存放修改后的playlistItem.playCount的数据,
        //如果直接就存放为自身playlistItem.playCount的话会陷入死循环
        //即不能给被监听数据本身赋值以防陷入死循环  
      })
    }
  },
```



### 详解wx:key/promise/async await看视频

在云函数里，由于 Node 版本最低是 8.9，因此是天然支持 async/await 语法的。而在小程序端则不然。在微信开发者工具里，以及 Android 端手机（浏览器内核是 QQ浏览器的 X5），async/await是天然支持的，但 iOS 端手机在较低版本则不支持，因此需要引入额外的 文件。可把这个 regenerator/runtime.js 文件引用到有使用 async/await 的文件当中。

```
import regeneratorRuntime from '../../utils/runtime.js'
```

### 【重要】读取歌单数据并插入云数据库

从服务器端取到歌单数据，并且把数据写入云数据库当中。其中，发送http请求在云函数中进行，然后把数据写进云数据库中。本项目用到的第三方服务器端数据为<http://musicapi.xiecheng.live/>，是一个大神从网易云音乐扒下来的数据。

为什么要在云函数中进行呢？

因为这个数据是从第三方获取到的，关键是这些音乐歌单等数据每天都会更新，如果只是获取一次的话，就无法做到数据的及时更新。所以，我们要在函数中设置一个定时触发器，也就是说会每天定时的从服务器中取数据，以保证取到的都是最新的数据。取到新数据后与旧数据进行比较，无则插入。而以上的这些功能，在云函数中完成最为合适。

#### 编写并上传云函数

在云函数中使用一个库[request-promise](https://github.com/request/request-promise)来进行对服务器端的请求。

我写的云函数路径为`/cloudfunctions/getPlaylist`，在该路径下安装`request`和`request-promise`。

```js
npm install --save request
npm install --save request-promise
```

编写云函数`getPlaylist`：

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 引入request-promise依赖
const rp = require("request-promise")

const URL = 'http://musicapi.xiecheng.live/personalized'
// 云函数入口函数
exports.main = async (event, context) => {
  const playlist = await rp(URL).then((res) => {
    // console.log(typeof res) //在云端测试打印结果为string，需要对其转为对象,并只取result数据
    return JSON.parse(res).result
  })
  console.log(playlist)
}
```

然后右键“上传并部署：云端安装依赖 ( 不上传node_modules ) ”。之后就可以在云开发中的云函数里看到这个`getPlaylist`云函数。点击云端测试可以对该函数进行测试。注意每次修改完云函数后都要重新上传并部署。


#### 建立云数据库

在云开发的数据库中新建集合`playlist`，小程序的云数据库是非关系型数据库，这里的集合类似于MySQL中的表。然后通过云函数中代码将从第三方服务器获取到的数据一条条地写入云数据库的表中。

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 得到云数据库对象
const db = cloud.database()

// 引入request-promise依赖
const rp = require("request-promise")

const URL = 'http://musicapi.xiecheng.live/personalized'
// 云函数入口函数
exports.main = async (event, context) => {
  const playlist = await rp(URL).then((res) => {
    // console.log(typeof res) //在云端测试打印结果为string，需要对其转为对象,并只取result数据
    return JSON.parse(res).result
  })
  // console.log(playlist)
  for(let i = 0; i<playlist.length; i++){
    // 注意，往云数据库里插入数据的过程是异步过程，也必须加上await关键字
    await db.collection('playlist').add({
      data:{
        ...playlist[i],//通过ES6展开运算符进行数据的展开
        createTime: db.serverDate(), //自定义一个属性，记录数据生成的时间
      }
    }).then((res)=>{
      console.log('插入成功')
    }).catch((err)=>{
      console.error('插入失败')
    })
  }
}
```

上面代码遍历了从第三方服务器获取到的数据并一条条插入了云数据库集合中，需要注意的是这里面的两处异步操作，都要加上`await`关键字。

然后上传并部署到云函数中，进行云端测试，测试结果是云数据库中成功的插入了数据。

#### 歌单数据去重

这一步要实现的是，云函数读取数据并插入进云数据库的时候，要对云数据库中的数据进行比对，如果数据已存在，则不插入，否则插入。

如何进行比对，比对的标志是歌单数据中的`id`值。

在云函数中获取到云数据库中的集合`playlist`，注意，它也是一个异步操作，需要加上`await`

```js
const list = await db.collection('playlist').get()
//但是云函数读取数据条数有限制，最多只能读取100条；如果是在小程序端读取最多只能20条
//之后会针对这一问题进行解决，这里暂时不表
```



```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 得到云数据库对象
const db = cloud.database()
// 得到云数据库中playlist集合对象
const playlistCollection = db.collection('playlist')

// 引入request-promise依赖
const rp = require("request-promise")

const URL = 'http://musicapi.xiecheng.live/personalized'
// 云函数入口函数
exports.main = async (event, context) => {
  // 从云数据库中取到的数据
  const list = await playlistCollection.get()

  // 从第三方服务器端取到的数据
  const playlist = await rp(URL).then((res) => {
    // console.log(typeof res) //在云端测试打印结果为string，需要对其转为对象,并只取result数据
    return JSON.parse(res).result
  })
  // console.log(playlist)

  // 下面进行数据去重，比较从服务器端获取到的数据和云数据库中的集合的数据是否重复
  const newData = []
  for(let i=0, len1=playlist.length; i<len1;i++){
    let flag = true  //一开始默认不重复，标志为true
    for(let j = 0, len2=list.data.length; j<len2; j++){
      if(playlist[i].id===list.data[j].id){
        flag = false  //数据重复了，标志置为false
        break  //有一次重复就跳出循环判断
      }
    }
    if (flag) {
      newData.push(playlist[i])
    }
  }
  // 删除云数据库里的数据，根据where里的条件清空数据
  // try {
  //   return await db.collection('playlist').where({
  //     // canDislike: false
  //     type: 0
  //   }).remove()
  // } catch (e) {
  //   console.error(e)
  // }

  for(let i = 0; i<newData.length; i++){
    // 注意，往云数据库里插入数据的过程是异步过程，也必须加上await关键字
    await playlistCollection.add({
      data:{
        // ...playlist[i],//通过ES6展开运算符进行数据的展开
        ...newData[i],  //不用playlist了，因为没有去重，应使用去重后的newData
        createTime: db.serverDate(), //自定义一个属性，记录数据生成的时间
      }
    }).then((res)=>{
      console.log('插入成功')
    }).catch((err)=>{
      console.error('插入失败')
    })
  }
  console.log("newdata的长度"+newData.length) 
  console.log("playlist的长度"+playlist.length)
}
```

上面代码中实现了数据的去重操作。在云开发之云函数中进行云端测试，然后查看云数据库中的数据，可以验证。



#### 【难点】突破获取数据条数限制，

前面说了，云函数读取数据条数有限制，最多只能读取100条；如果是在小程序端读取最多只能20条。随着时间的改变，歌单信息只会越来越多，这个限制是会影响这个项目的。` const list = await playlistCollection.get()`以及无法满足需求了。这个问题如何解决？

【解决思路】👇

之前使用` const list = await playlistCollection.get()`企图一次性获取到云数据库中playlist集合的所有记录，如果总数小于100，那还好说，但是实际上数据肯定会越来越多的。

**那么我们就每次只获取20条数据，然后分多次获取，这样就可以全部获得云数据库的数据。**

```js
const MAX_LIMIT = 20 //每次读取云数据库的数据云函数中一次只能获取100条，小程序端一次只能获取20条，这里我们进行自定义一次性最大读取数
// 云函数入口函数
exports.main = async (event, context) => {
  // 从云数据库中取到的数据
  // const list = await playlistCollection.get() //不适用了。云函数中一次只能获取100条，小程序端一次只能获取20条
  const countResult = await playlistCollection.count()  //获取到的是一个对象{ total: 30, errMsg: 'collection.count:ok' }
  const total = countResult.total  //取到云数据库中playlist集合的记录的总条数
  // 得出需要向云数据库分多次读取数据的批次
  const batchTimes = Math.ceil(total/MAX_LIMIT)  
  const tasks = []
  for(let i = 0; i<batchTimes; i++){
    let promise = playlistCollection.skip(i*MAX_LIMIT).limit(MAX_LIMIT).get()
    // 这就得到了从第0条取到第99条，从第100条取到第199条，从第200条取到第299条。。。（前提是MAX_LIMIT为100的时候）
    tasks.push(promise)
  }
    // console.log(tasks) //里面是若干个promise对象
  let list = {
    data:[]
  }
  if(tasks.length>0){
    // 使用了promise.all
    list = (await Promise.all(tasks)).reduce((acc, cur)=>{
      return {
        data: acc.data.concat(cur.data)
      }
    })
  }
  // 至此分批读取云数据库的数据完成，解决了小程序读取云数据库数据条数的限制
```

这里面用到了【promise.all】

在云开发之云函数中进行云端测试，然后查看云数据库中的数据，可以验证



#### 设计定时触发器以定时触发获取数据的函数getPlaylist()

关于定时触发器<https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/triggers.html>

在getPlaylist函数的目录下新建一个配置文件config.json👇

其中`"config": "0 0 10,14,16,23 * * * *"`表示在每天上午10点，下午2点，4点和晚上11点触发，这样歌单信息一天就会有四次更新。（更新的歌单信息来自网易云音乐更新的推荐歌单）

```
{
  "triggers": [
    {
      "name": "myTrigger",
      "type": "timer",
      "config": "0 0 10,14,16,23 * * * *"
    }
  ]
}
```

之后要上传触发器。点击当前云函数getPlaylist，鼠标右键点击”上传触发器“。这样这个定时触发器才能生效。



在云开发控制台的云函数中，有一个“配置”选项，点击，更改里面的“超时时间”，改为20秒比较合适。

至此，云函数`getPlaylist`的开发大致完成。



### 从云数据库中获取数据并渲染到页面中

<img src="https://pic4.zhimg.com/v2-26cc4fde482475db8c039fd0462522ef_r.jpg" style="width:300px" />

#### 新建music云函数

这个music云函数用于查询歌单信息。

【注意】由于歌单数据会很多，所以要做到**分页**的查询数据，且查询结果按数据创建按时间倒序排序

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
  // 查询歌单数据，并且是分页查询，按数据创建时间倒序排序
   return await cloud.database().collection('playlist')
   .skip(event.start)
   .limit(event.count)
   .orderBy('createTime', 'desc')
   .get()
   .then((res)=>{
     return res
   })
}
```



#### 调用music云函数

接着在`miniprogram/pages/playlist/playlist.js`中调用该云函数获取云数据库的歌单数据。

```js
  onLoad: function (options) {
    this._getPlaylist()
  },

  _getPlaylist(){
    wx.showLoading({
      title: '加载中',
    })

    wx.cloud.callFunction({
      name: 'music',
      data: {
        start: this.data.playlist.length,
        count: MAX_LIMIT
      }
    }).then((res) => {
      // console.log(res)
      this.setData({
        playlist: this.data.playlist.concat(res.result.data) //注意是追加歌单数据而非替换歌单数据
      })
      wx.hideLoading() //记得关闭loading
    })
  },
```



#### 上拉触底刷新和下拉刷新

上拉触底刷新👇

```js
  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    this._getPlaylist()
  },
```



下拉刷新就比上拉触底复杂一点

在`/miniprogram/pages/playlist/playlist.json `中进行如下配置👇 

```json
{
  "usingComponents": {
    "playlist-cmp": "/components/playlist/cmp"
  },
  "enablePullDownRefresh": true
}
```

小程序默认是不开启下拉刷新的，通过配置将其置为允许下拉刷新

然后就可以在**onPullDownRefresh**的监听函数中进行代码编写

```js
  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    // 下拉刷新动作是要先清空数据,然后再重新请求数据
    this.setData({
      playlist:[]  
    })
    this._getPlaylist()
  },
```



### 云函数路由优化tcb-router

关于tcb-router我写的一篇笔记👉<https://juejin.im/post/5dd930385188257353094a2d>

#### 背景：

一个用户在一个云环境中只能创建50个云函数，之前是20个，更少。当我们要获取歌曲信息的时候可能要创建一个云函数，要获取电影信息的时候又要创建一个云函数。。。。随着业务的增多，创建的对应的云函数数目越来越多，50个可能不够用，而且这种做法也很冗杂。

所以希望把相似的请求归类到同一个云函数处理，比如我们把获取音乐信息和获取电影信息都在同一个云函数里实现，从而避免创建多个云函数的情况。

要实现这一功能就要用到一个第三方库——[tcb-router](https://github.com/TencentCloudBase/tcb-router) 一个koa风格的云函数路由库。



#### koa洋葱模型

koa框架采用了【中间件】的形式，中间件可以介入请求和相应的处理，可以理解是一个轻量级的模块，或者在我们的代码当中是一个函数形式。中间件可以负责一个特定的功能，通过一个`next`函数把每个中间件之间建立关系。

什么是【洋葱模型】？

![](https://ask.qcloudimg.com/http-save/yehe-1000017/uuitxvbg4y.jpeg?imageView2/2/w/1620)

![](https://images0.cnblogs.com/blog2015/570057/201507/281409123445079.jpg)

#### 新建tcbRouter云函数•举个例子

tcb-router：<https://github.com/TencentCloudBase/tcb-router>

我们实现一个功能：把获取音乐信息和获取电影信息都在同一个云函数里实现，两者都要获取`用户openid`并且获取各自的信息，从而避免创建多个云函数的情况。

在tcbRouter云函数的目录下安装tcb-router依赖👇

```
npm install --save tcb-router
```



云函数**tcbRouter**

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')
// 引入tcb-router
const TcbRouter = require('tcb-router')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
  // return {event,context}  //看看event和context到底是啥

  // new一个TcbRouter对象,需要传入一个参数,把event传入
  // 这时候tcb-router就会自动帮我们处理事件中的参数和路由转发
  const app = new TcbRouter({event})

  // 公共路由
  // app.use 表示该中间件会适用于所有的路由
  app.use(async (ctx,next)=>{
    console.log('进入全局中间件')
    ctx.data = {}
    ctx.data.openId = event.userInfo.openId //通过该公共路由获取到用户openid
    await next()  //执行一下中间件.这是一个异步操作,要加上await
    console.log('退出全局中间件')
  })

  // music相关的路由
  app.router('music', async (ctx,next)=>{
    console.log('进入音乐名称路由中间件')
    ctx.data.musicName = "Let it be"
    await next()  //执行一下中间件
    console.log('退出音乐名称路由中间件')
  }, async (ctx, next)=>{
    console.log('进入音乐类型路由中间件')
    ctx.data.musicType = '摇滚乐'
    ctx.body = {
      data: ctx.data
    }
    // ctx.body 返回数据到小程序端
    console.log('退出音乐类型路由中间件')
  })

  // movie相关的路由
  app.router('movie', async (ctx,next)=>{
    console.log('进入电影名称路由中间件')
    ctx.data.movieName = "千与千寻"
    await next()  //执行一下中间件
    console.log('退出电影名称路由中间件')
  }, async (ctx, next)=>{
    console.log('进入电影类型路由中间件')
    ctx.data.movieType = '动漫'
    ctx.body = {
      data: ctx.data
    }
    // ctx.body 返回数据到小程序端
    console.log('退出电影类型路由中间件')
  })

  // // 必须写! 需要把当前的服务返回
  return app.serve()
}
```

小程序端调用tcbRouter函数👇

```js
 //demo.js
 getMusicInfo(){
    wx.cloud.callFunction({
      name: 'tcbRouter',
      data: {
        $url: 'music'
      }
    }).then((res)=>{
      console.log(res)
    })
  },
  getMovieInfo(){
    wx.cloud.callFunction({
      name: 'tcbRouter',
      data:{
        $url: 'movie'
      }
    }).then((res)=>{
      console.log(res)
    })
  },
```

上面这段代码两个方法实际上调用的都是同一个云函数**tcbRouter**，但实现了不同的功能。

![](https://pic1.zhimg.com/v2-928c9ce713a0d13a92d18d6abe21b910_r.jpg)



为了更加直观的体现【洋葱模型】这一概念在该例子上的应用，我们可以在云开发控制台的云函数运行日志中查看打印的日志👇

![](https://pic3.zhimg.com/v2-0484ed79f891b5e7b2e82ad95296e6ca_r.jpg)

![](https://images0.cnblogs.com/blog2015/570057/201507/281409123445079.jpg)



#### tcbRouter对music云函数进行改造

前面说过，我们要把**相似的请求归类到同一个云函数处理**。

在云函数music所对应的目录下安装tcb-router依赖：

```j
npm install --save tcb-router
```



云函数music👇

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')
// 引入tcb-router
const TcbRouter = require('tcb-router')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
  const app = new TcbRouter({event})

  app.router('playlist', async (ctx,next)=>{
    // 查询歌单数据，并且是分页查询，按数据创建时间倒序排序
    // 注意,没使用tcb-router之前是用retur返回,现在要用 ctx.body 返回数据到小程序端
    ctx.body = await cloud.database().collection('playlist')
      .skip(event.start)
      .limit(event.count)
      .orderBy('createTime', 'desc')
      .get()
      .then((res) => {
        //  console.log(res)
        return res
      })
  })
  // 必须写! 需要把当前的服务返回
  return app.serve()

}
```

重新上传并部署该云函数。

通过tcb-router改造后，调用music云函数的方式也要进行修改👇

```js
  ///miniprogram/pages/playlist/playlist.js 
  
  _getPlaylist(){
    wx.showLoading({
      title: '加载中',
    })

    wx.cloud.callFunction({
      name: 'music',
      data: {
        start: this.data.playlist.length,
        count: MAX_LIMIT,
        // 云函数music被tcb-router化后要使用$url指定路由
        $url: 'playlist'
      }
    }).then((res) => {
      // console.log(res)
      this.setData({
        playlist: this.data.playlist.concat(res.result.data) //注意是追加歌单数据而非替换歌单数据
      })
      wx.stopPullDownRefresh() //关闭下拉刷新动作，这步不写的话真机不会回弹页面
      wx.hideLoading() //记得关闭loading
    })
  },
```



<br>

### 自定义歌曲列表组件

#### 路由跳转

在首页的歌单列表中，每点击一个歌单都跳转到相对应的歌曲列表里面，用`wx.navigateTo`进行路由跳转，在此之前要配置页面路由信息。在`app.json`中添加`"pages/musiclist/musiclist"`。

为歌单组件绑定一个点击事件，点击触发函数`goToMusiclist`:

```js
// miniprogram/components/playlist/cmp.js   

	// 显示歌曲列表
    goToMusiclist() {
      wx.navigateTo({
        url: `../../pages/musiclist/musiclist?playlistId=${this.properties.playlistItem.id}`
      })
    }
```

这样就把歌单数据的`id`作为参数传进路由里了，然后我们在目标路由对应的页面打印出路由参数👇

```js
// miniprogram/pages/musiclist/musiclist.js  
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log(options)
  },
```

可以获取到传过来的参数`id`。根据这个`id`可以向后端api获取到对应歌曲列表的数据

#### 获取歌曲数据

前面说过，我们要把**相似的请求归类到同一个云函数处理**。所以，这里把获取歌单对应的歌曲列表信息的处理也放在云函数music里，通过tcb-router进行任务派发。

这里涉及到发送http请求的操作（向后端api发送ajax请求），所以在云函数music所在目录下安装`request`和`request-promise`依赖。



给云函数music添加获取歌单内歌曲列表数据的路由处理函数musiclist👇

```js
// cloudfunctions/music/index.js 

// 引入request-promise
const rp = require('request-promise')

const BASE_URL = 'http://musicapi.xiecheng.live'
//用 ctx.body 返回数据到小程序端
 app.router('musiclist', async (ctx, next)=>{
    ctx.body = await rp(BASE_URL+'/playlist/detail?id='+event.playlistId)
    .then((res)=>{
      return JSON.parse(res)
    })
  })
```

然后在歌单详情页对应的`/miniprogram/pages/musiclist/musiclist.js `中获得数据并保存👇

```js
  data: {
    //歌单详情信息
    listInfo: {},
    // 歌曲列表
    musiclist: []
  },
  
    /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log(options) //可以获取到路由传进来的参数，这里是歌单id
    wx.cloud.callFunction({
      name: 'music',
      data:{
        playlistId: options.playlistId,
        $url: 'musiclist'
      }
    }).then((res)=>{
      // console.log(res)
      const pl = res.result.playlist
      this.setData({
        musiclist: pl.tracks,
        listInfo: {
          coverImgUrl: pl.coverImgUrl,
          name: pl.name
        }
      })
    })
  },
```

这里可以配置一下云函数music的超时时间，默认是3秒，这导致很多图片没来得及加载项目报错，故可以在云开发控制台设置music云函数的超时事件为20秒。



#### 渲染歌单歌曲列表详情页面musiclist

从上一步已经获取到后端数据并保存在了musiclist.js的data中了，所以直接开始数据渲染就行了。

详情页的头部背景图进行了**高斯模糊**的处理。

```html
<!--pages/musiclist/musiclist.wxml-->
<view class="detail-container" style="background:url({{listInfo.coverImgUrl}}) center/cover no-repeat"></view>
<view class="detail-mask"></view>
```



```js
.detail-container{
  height: 320rpx;
  filter: blur(40rpx);  /*css3滤镜属性*/
  opacity: 0.4;
}

.detail-mask{
  position: absolute;
  width: 100%;
  height: 320rpx;
  background-color: #333;
  top: 0;
  left: 0;
  z-index: -1;
}
```



#### musiclist组件开发

上面提到的歌单歌曲列表详情页面的头部背景图已经完成了，该页面下面的部分就是歌曲列表的展示，这一步可以封装成一个组件，方便之后的复用。

新建一个component：/miniprogram/components/musiclist/cmp

我们想要在`/miniprogram/pages/musiclist/musiclist.wxml `中引用该组件，要先在`/miniprogram/pages/musiclist/musiclist.json `中进行注册引入👇

```json
{
  "usingComponents": {
    "musiclist-cmp": "/components/musiclist/cmp"
  }
}
```

然后在使用用这个组件的时候，将歌曲数据作为其属性值传入，`musiclist-cmp`组件在`musiclist/cmp.js `中的`properties`中进行接收。

之后就可以进行布局和数据渲染实现该组件的页面显示部分了。

<img src="https://pic1.zhimg.com/v2-1f2f1b731031c2db538fe6c1481eb700_r.jpg" style="width:300px" />



#### 歌曲点击样式高亮

现在想要点击一首歌，其文字变成红色样式。

这就要取到该歌曲的索引，这里使用了两个个自定义属性。绑定一个点击事件触发函数获取到该索引并修改其样式。

```html
// /miniprogram/components/musiclist/cmp.wxml  
<view class="musiclist-container" bindtap="onSelect" data-musicid="{{item.id}}" data-index="{{index}}">
```

注意自定义属性都是`data-xxx`的格式，通过`event.currentTarget.dataset.musicid`来获取到该自定义属性。

```
    onSelect(event){
      console.log(event)
      console.log(event.currentTarget.dataset.musicid)
    }
```

进一步该其加上样式，注意这里的判断操作`{{item.id===playingId?'playing':''}}`👇

```html
  <view class="musiclist-container  {{item.id===playingId?'playing':''}}" bindtap="onSelect" data-musicid="{{item.id}}" data-index="{{index}}">
```

```
.playing view, .playing text{
  color: #d43c43;
}
```

这样每次点击歌曲，被点击的歌曲的样式就会变红.

接下来就是要在点击了歌曲之后进入歌曲的播放页，同时把`playingId`即歌曲的`id`和`index`传进去。

```js
    onSelect(event){
      // console.log(event)
      // console.log(event.currentTarget.dataset.musicid)
      const ds = event.currentTarget.dataset
      this.setData({
        playingId: ds.musicid
      })
      wx.navigateTo({
        url: `../../pages/player/player?musicId=${ds.musicid}&index=${ds.index}`,
      })
    }
```

在`app.json`中配置新的页面`pages/player/player`，之后的播放页在这里进行实现。

```json
  "pages": [
    "pages/playlist/playlist",
    "pages/blog/blog",
    "pages/profile/profile",
    "pages/demo/demo",
    "pages/musiclist/musiclist",
    "pages/player/player"
  ],
```



## 4.播放器功能实现

```
- 媲美原生体验的小程序音乐播放器
- 歌词解析和播放事件联动
- 性能优化
- 引入iconfont字体图标
```

### 本地缓存歌曲信息

获取歌曲信息前面说了可以通过歌曲列表里被点击的该歌曲的id值，通过发送网络请求获得该歌曲的详细信息。但其实在歌曲列表阶段，歌曲列表数据获取的时候，每一首歌的信息都已经拿到了，所以不必再去调用新的网络请求。那么要怎么保存在歌曲列表阶段得到的歌曲信息呢？这里用到了**本地缓存**。

所以又要回到上一个阶段——歌曲列表组件阶段。在获取到歌曲列表信息的时候，要将其存入本地缓存。

在开发者工具调试器中的Storage中可以看到，`wx.setStorageSync`是数据覆盖的而不是数据追加的，所以每次只保存当前点击进来的歌单的数据。

/miniprogram/pages/musiclist/musiclist.js 👇

```js
  onLoad: function (options) {
    wx.showLoading({
      title: '加载中',
    })
    console.log(options) //可以获取到路由传进来的参数，这里是歌单id
    wx.cloud.callFunction({
      name: 'music',
      data:{
        playlistId: options.playlistId,
        $url: 'musiclist'
      }
    }).then((res)=>{
      // console.log(res)
      const pl = res.result.playlist
      this.setData({
        musiclist: pl.tracks,
        listInfo: {
          coverImgUrl: pl.coverImgUrl,
          name: pl.name
        }
      })
      this._setMusiclist() // 歌曲列表信息存入缓存
      wx.hideLoading()
    })
  },

  _setMusiclist(){
    wx.setStorageSync('musiclist', this.data.musiclist)
  },
```



### 获取本地缓存信息并渲染页面

本地缓存了一个歌曲列表的信息，是一个数组的格式。而在播放页里传进了两个自定义属性`data-musicid `和` data-index`，通过这个`data-index`就能直接获取到当前播放歌曲的信息。

```js
  // pages/player/player.js

	//用于存放获取到的本地缓存信息
	let musiclist = [] 
	// 正在播放的歌曲的index
	let nowPlayingIndex = 0

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log(options)
    nowPlayingIndex = options.index
    musiclist = wx.getStorageSync('musiclist')
    this._loadMusicDetail()
  },

  _loadMusicDetail(){
    // 当前播放歌曲的信息
    let music = musiclist[nowPlayingIndex]
    console.log(music)

    wx.setNavigationBarTitle({
      title: music.name
    })

    this.setData({
      picUrl: music.al.picUrl
    })
  },
```

在页面渲染部分，依旧使用了一个高斯模糊的效果，然后做了一个黑胶唱机指针的效果，使用CSS3动画效果👇

![](https://pic1.zhimg.com/80/v2-33ce6d02c02b02b90e2e74293dbfcd40_hd.jpg)

### 小程序引入icofont字体图标实现播放控件部分

在[icofont](https://www.iconfont.cn/)官网中挑选几个图片，加入购物车，然后添加到项目中，点击font class，点击在线链接，然后在新标签页打开该链接，发现是一段css代码，将其拷贝下来保存在我们的小程序根路径下命名为`iconfont.wxss`，然后在`app.wxss`中引入，这样全局下都可以使用这个字体图标。

```css
@import 'iconfont.wxss';
```

在需要引用字体图标的页面如下引用即可，这样比起直接下载图标文件更加节省项目大小。

```html
<view class="control">
  <text class="iconfont icon-fast-backward"></text>
  <text class="iconfont icon-play-circle-fill"></text>
  <text class="iconfont icon-poweroff-circle-fill"></text>
  <text class="iconfont icon-fast-forward"></text>
</view>
```

接下来给它们添加样式即可。

### 播放控件功能实现

继续补充云函数`music`里面的功能👇

```js
  app.router('musicUrl', async(ctx,next)=>{
    ctx.body = await rp(BASE_URL+`/song/url?id=${event.musicId}`).then((res)=>{
      return res
    })
  })
```

之后上传更新云函数。

在中使用该云函数`music`中的`musicUrl`中间件👇

```js
    wx.cloud.callFunction({
      name: 'music',
      data:{
        musicId,
        $url: 'musicUrl'
      }
    }).then(res=>{
      console.log(JSON.parse(res.result)) //将字符串json格式化成对象格式
    })
```

这结果中的url就是该歌曲的源。

接下来利用小程序里的一个[背景音频管理器功能`wx.getBackgroundAudioManager()`](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/BackgroundAudioManager.html)将歌曲播放出来👇

```js
// miniprogram/pages/player/player.js 

// 获取全局唯一的背景音频管理器
const backgroundAudioManager = wx.getBackgroundAudioManager()

    wx.cloud.callFunction({
      name: 'music',
      data:{
        musicId,
        $url: 'musicUrl'
      }
    }).then(res=>{
      console.log(JSON.parse(res.result))
      let result = JSON.parse(res.result)
      backgroundAudioManager.src = result.data[0].url  //歌曲源
      backgroundAudioManager.title = music.name //歌曲名
      backgroundAudioManager.coverImgUrl = music.al.picUrl //歌曲封面
      backgroundAudioManager.singer = music.ar[0].name //歌手名
      backgroundAudioManager.epname = music.al.name //专辑名
    })
```

可以播放歌曲了！

![](https://pic4.zhimg.com/v2-256cf023641f1d8e8bd50be69690e28b_r.jpg)

这里可以看到一个提示👉VM211:1 若需要小程序在退到后台后继续播放音频，你需要在 app.json 中配置 requiredBackgroundModes 属性，详见: https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#requiredbackgroundmodes

```a&#39;p
  "requiredBackgroundModes": [
    "audio"
  ],
```

开发版和体验版上可以直接生效，正式版还需通过审核。



用一个变量`isPlaying`来表示当前是否有音乐在播放，接下来播放按钮的切换和歌曲封面的旋转和指针的摆放都围绕这个变量来控制👇

```js
  data: {
    picUrl: '',
    isPlaying: false
  },
```

按钮的切换👇

```html
  <text class="iconfont {{isPlaying?'icon-poweroff-circle-fill':'icon-play-circle-fill'}}" bindtap="togglePlaying"></text>
```

通过`backgroundAudioManager.pause() `和`backgroundAudioManager.play()`来控制音乐的暂停和播放。

```js
  togglePlaying(){
    if(this.data.isPlaying){
      backgroundAudioManager.pause()  
    }else{
      backgroundAudioManager.play()
    }
    this.setData({
      isPlaying: !this.data.isPlaying
    })
  },
```

封面旋转👇

```html
<image class="player-img rotation {{isPlaying?'':'rotation-paused '}}" src="{{picUrl}}"></image>
```

歌曲暂停的时候，封面要停在那一帧的状态，使用CSS3里的`animation-play-state: paused;`

```css
.rotation{
  animation: rotation 12s linear infinite;
  -moz-animation: rotation 12s linear infinite;
  -webkit-animation: rotation 12s linear infinite;
  -o-animation: rotation 12s linear infinite ;
}
.rotation-paused{
  /* 定格在动画的某一帧 */
  animation-play-state: paused;
}
@keyframes rotation{
  from{
    transform: rotate(0deg);
  }
  to{
    transform: rotate(360deg);
  }
}
```

指针的摆放👇

```html
<view class="player-disc {{isPlaying?'play':''}}">
```

```css
.player-disc::after{
  content: '';
  width: 192rpx;
  height: 274rpx;
  position: absolute;
  top: -150rpx;
  left: 266rpx;
  background: url('https://s3.music.126.net/m/s/img/needle.png?702cf6d95f29e2e594f53a3caab50e12') no-repeat center/contain;
  transform: rotate(-15deg);
  transform-origin: 24rpx 10rpx;
  transition: transform 0.5s ease;
}
.play.player-disc::after{
  transform: rotate(0deg)
}
```

上一首/下一首切换👇

```js
  onPrev(){
    nowPlayingIndex--
    if(nowPlayingIndex<0){
      nowPlayingIndex = musiclist.length-1
    }
    this._loadMusicDetail(musiclist[nowPlayingIndex].id)
  },
  onNext(){
    nowPlayingIndex++
    if (nowPlayingIndex == musiclist.length) {
      nowPlayingIndex = 0
    }
    this._loadMusicDetail(musiclist[nowPlayingIndex].id)
  },
```

### 进度条组件

#### 结构布局

新建进度条组件`/miniprogram/components/progress-bar/cmp `，播放页要引用，所以在`/miniprogram/pages/player/player.json `中引入该组件👇

```json
{
  "usingComponents": {
    "progress-bar": "../../components/progress-bar/cmp"
  }
}
```

开始编写该组件代码。

进度条需要可以移动，这里用到了新的标签`<progress>`、 `<movable-area>`和`<movable-view>`。详见[文档](https://developers.weixin.qq.com/miniprogram/dev/component/movable-area.html)

初步的布局👇

```html
<!--components/progress-bar/cmp.wxml-->
<view class="container">
  <text class="time">{{showTime.currentTime}}</text>
  <view class="control">
    <movable-area class="movable-area">
      <movable-view direction="horizontal" class="movable-view" damping="1000" x="{{movableDis}}" ></movable-view>
    </movable-area>
    <progress stroke-width="4" backgroundColor="#969696" activeColor="#fff" percent="{{progress}}"></progress>
  </view>
  <text class="time">{{showTime.totalTime}}</text>
</view>
```

```css
.container{
  display: flex;
  align-items: center;
}

.control {
  position: relative;
  flex: 1;
}
.movable-area{
  width: 100%;
  height: 34rpx;
  position: absolute;
  bottom: -14rpx;
  left: 0;
}
.movable-view{
  width: 36rpx;
  height: 36rpx;
  background-color: #fefefe;
  border-radius: 50%;
}
.time{
  color: #fff;
}
```

![](https://pic1.zhimg.com/80/v2-c771a30feb89a12d41d60ff182430908_hd.jpg)



#### 获取节点布局信息

小程序中没有Dom操作，但是依然能通过某些方法获取到元素节点。

[wx.createSelectorQuery()](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html)返回一个 [SelectorQuery](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.html) 对象实例。在自定义组件或包含自定义组件的页面中，应使用 **this.createSelectorQuery()** 来代替

```js
// miniprogram/components/progress-bar/cmp.js   
// 组件生命周期
  lifetimes:{
    ready(){
      this._getMovableDis()
    }
  },

  /**
   * 组件的方法列表
   */
  methods: {
    _getMovableDis(){
      // wx.createSelectorQuery()返回一个 SelectorQuery 对象实例。在自定义组件或包含自定义组件的页面中，应使用 this.createSelectorQuery() 来代替
      const query = this.createSelectorQuery()
      query.select('.movable-area').boundingClientRect()
      query.select('.movable-view').boundingClientRect()
      query.exec((rect)=>{
        console.log(rect)
        movabelAreaWidth = rect[0].width
        movableViewWidth = rect[1].width
      })
    }
  }
```

打印结果如下，可以看到，小程序虽然无法获取到dom元素，但是可以得到节点的布局、大小、位置信息👇

![](https://pic3.zhimg.com/80/v2-991622b5bbeea7bad6b1943e3808bbbe_hd.jpg)

接下来就可以通过这些信息改变进度条中滑块的位置。



#### backgroundAudioManager的方法和获取歌曲总时间

```js
    _bindBGMEvent(){
      backgroundAudioManager.onPlay(()=>{
        console.log('onPlay')
      })
      backgroundAudioManager.onStop(() => {
        console.log('onStop')
      })
      backgroundAudioManager.onPause(() => {
        console.log('onPause')
      })
      backgroundAudioManager.onWaiting(() => {
        console.log('onWaiting')
      })
      backgroundAudioManager.onCanplay(() => {
        console.log('onCanplay')
        console.log(backgroundAudioManager.duration) //结果有时候为undefined有时候又可以正确获取到歌曲总时长，小程序的一个坑。所以这下面进行一下处理
        if(typeof backgroundAudioManager.duration != 'undefined'){
          // 如果不为undefined则是正确取到了duration
          this._setTime()
        }else{
          // 否则可以使用定时器，过一秒之后再取duration。 奇技淫巧
          setTimeout(()=>{
            this._setTime()
          },1000)
        }
      })
      backgroundAudioManager.onTimeUpdate(() => {
        // 播放过程中一直都会发生，暂停的时候发生一次，页面切换时又会重新发生
        console.log('onTimeUpdate')
      })
      backgroundAudioManager.onEnded(() => {
        console.log('onEnded')
      })
      backgroundAudioManager.onError(() => {
        console.log('onError')
      })
    },
```

```js
    _setTime(){
      const duration = backgroundAudioManager.duration
      console.log(duration)  //是秒的格式
      const durationFmt = this._TimeFormat(duration) //格式化为分秒格式
      console.log(durationFmt)
      this.setData({
        ['showTime.totalTime']: `${durationFmt.min}:${durationFmt.sec}`
      })
    },

    _TimeFormat(second){
      const min = Math.floor(second / 60) 
      const sec = Math.floor(second % 60)
      return {
        'min': this._add0(min),
        'sec': this._add0(sec)
      }
    },
    // 对于小于10的分和秒要在前面补上0
    _add0(time){
      return time<10?'0'+time:''+time
    }
```

这里注意一下在setData的时候如果只想改变对象中的一个属性，可以使用这种格式设置👉` ['obj.abc']: xxx`。

上面的方法获取到了当前播放歌曲的总时长，经过格式化之后赋值给 `showTime.totalTime`，效果如下👇

![](https://pic1.zhimg.com/80/v2-5ece2082a119f4ff917fdeff27a5fb3c_hd.png)



#### 进度条与播放状态联动

```html
      <movable-view direction="horizontal" class="movable-view" damping="1000" x="{{movableDis}}" ></movable-view>
    </movable-area>
    <progress stroke-width="4" backgroundColor="#969696" activeColor="#fff" percent="{{progress}}"></progress>
```

`<movable-view>`中的`x`属性就是其距离左边的长度，`<progress>`中的`percent`属性是滑动条左侧的距离，进度条二还播放事件的联动关键就是改变这两者的数值大小，而这个过程在`backgroundAudioManager.onTimeUpdate()`中发生。

```js
      backgroundAudioManager.onTimeUpdate(() => {
        // 播放过程中一直都会发生，暂停的时候发生一次，页面切换时又会重新发生
        console.log('onTimeUpdate')
        const currentTime = backgroundAudioManager.currentTime
        console.log(currentTime)
        const duration = backgroundAudioManager.duration
        const currentTimeFmt = this._TimeFormat(currentTime)
        this.setData({
          movableDis:(movabelAreaWidth-movableViewWidth)*currentTime/duration,
          progress: currentTime / duration * 100,
          ['showTime.currentTime']: `${currentTimeFmt.min}:${currentTimeFmt.sec}`
        })
      })
```

上面代码中获取当前背景音乐播放时间用的是`backgroundAudioManager.currentTime`。



##### 【优化】

![](https://pic1.zhimg.com/80/v2-37f63012c6134f77b7daae1b6ddcbb0b_hd.png)

这个联动靠的是`currentTime`，但是`currentTime`每一秒中有好几个，导致一秒内程序就设置了好几次相同的数据。要做得优化就是减少这种重复的赋值👇

```js
	let currentSec = -1 //当前秒数

      backgroundAudioManager.onTimeUpdate(() => {
        // 播放过程中一直都会发生，暂停的时候发生一次，页面切换时又会重新发生
        // console.log('onTimeUpdate')
        const currentTime = backgroundAudioManager.currentTime
        // console.log(currentTime)
        const duration = backgroundAudioManager.duration
        let sec = currentTime.toString().split('.')[0]
        if(sec!=currentSec){
          console.log(sec)
          const currentTimeFmt = this._TimeFormat(currentTime)
          this.setData({
            movableDis:(movabelAreaWidth-movableViewWidth)*currentTime/duration,
            progress: currentTime / duration * 100,
            ['showTime.currentTime']: `${currentTimeFmt.min}:${currentTimeFmt.sec}`
          })
          // 更新currentSec
          currentSec = sec
        }else{
          // 秒数相同的情况下就不再重复进行上述的赋值操作了，优化性能
        }
      })
```



#### 拖拽进度条

要实现手动拖拽进度条进而改变歌曲播放进度，这里就要给标签`movable-view`添加一个`bindchange`事件，但是同时要注意到，如果用户反复左右拖拽进度条，这会使得事件不断触发，这是对小程序的性能影响很不好的一件事。所以在这里要做一个处理。再给标签`movable-view`添加一个`bindtouchend`事件，表示当前触摸结束手离开屏幕的时候触发事件。👇

```html
<movable-view direction="horizontal" class="movable-view" damping="1000" x="{{movableDis}}" bindchange="onChange" bindtouchend="onTouchEnd"/>
```

当用户每次取拖拽移动进度条的时候，函数onChange获取到移动到的距离，当结束拖拽触发touchend的时候，再在onTouchEnd里面通过setData的方式，把当时的状态设置到进度条中。但是这里要注意到，我们之前设置了进度条与播放状态联动的功能，通过setData改变movableDis，所以在歌曲正常播放的时候进度条是在走的，也是在不断触发onchange函数的，所以这里onchange函数要处理判断以下什么时候是用手拖拽导致的状态改变，什么时候是歌曲正常播放导致的状态改变，这里通过`event.detail.source`来判断，（[详见文档](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html)）当`event.detail.source`的值为空字符串的时候表示是歌曲播放引起的状态改变，这时不做处理；当`event.detail.source`的值为'touch'的时候，说明是手动拖拽引起的，这时就要进行相关处理了。

```js
    // miniprogram/components/progress-bar/cmp.js 
	onChange(event){
      console.log(event)
      // 拖动
      if(event.detail.source == 'touch'){
        this.data.progress = event.detail.x / (movabelAreaWidth-movableViewWidth)*100
        this.data.movableDis = event.detail.x
        // 拖动过程中不断保存更新每个瞬间的状态
      }

    },
    onTouchEnd(){
      const currentTimeFmt = this._TimeFormat(Math.floor(backgroundAudioManager.currentTime))
      this.setData({
        progress: this.data.progress,
        movableDis: this.data.movableDis,
        ['showTime.currentTime']: currentTimeFmt.min + ":" + currentTimeFmt.sec
      })
      // 背景音乐跳转到拖拽处对应的时刻
      backgroundAudioManager.seek((this.data.progress/100)*duration)
      
    },
```

这样手动拖拽进度条的功能就实现了。

##### 【优化】

到目前为止，手动拖拽进度条并使歌曲跳转到对应的状态这一功能是实现了，但是还有个bug要优化——在我们用手拖拽进度条的时候，滑块有时候会跳回去原来的位置。因为歌曲一直在播放，而这个播放过程中一直在更新进度条的状态，👇

```js
      backgroundAudioManager.onTimeUpdate(() => {
        // 播放过程中一直都会发生，暂停的时候发生一次，页面切换时又会重新发生
        // console.log('onTimeUpdate')
        const currentTime = backgroundAudioManager.currentTime
        // console.log(currentTime)
        const duration = backgroundAudioManager.duration
        let sec = currentTime.toString().split('.')[0]
        if(sec!=currentSec){
          // console.log(sec)
          const currentTimeFmt = this._TimeFormat(currentTime)
          this.setData({
            movableDis:(movabelAreaWidth-movableViewWidth)*currentTime/duration,
            progress: currentTime / duration * 100,
            ['showTime.currentTime']: `${currentTimeFmt.min}:${currentTimeFmt.sec}`
          })
          // 更新currentSec
          currentSec = sec
        }else{
          // 秒数相同的情况下就不再重复进行上述的赋值操作了，优化性能
        }
      })
```

我们希望在拖拽进度条的时候暂停因歌曲播放导致的更新进度条操作。

我们要加上一个【锁结构】

```js
// 标志当前进度条是否在拖拽，如果false则onTimeUpdate时更新状态，否则上锁
// 解决当进度条拖动的时候和backgroundAudioManager.onTimeUpdate事件冲突问题
let isMving = false 
...
  methods: {
    onChange(event){
      if(event.detail.source == 'touch'){
        isMoving = true //上锁
        ...
      }

    },
    onTouchEnd(){
      ...
      isMoving = false //解锁
    },
	 _bindBGMEvent(){
      backgroundAudioManager.onPlay(()=>{
        isMoving = false //解锁,在这里解锁是最保险的，因为有时候onTouchEnd解锁后又会触发onChange，算是小程序的一个坑
      })
```

只有当isMoving为false的时候才进行后续的setData👇

![](https://pic2.zhimg.com/80/v2-f32bcc5c7816021b5f20c323aa94d01b_hd.png)



### 自动播放下一首

当前歌曲播放完成后会触发backgroundAudioManager一个onEnded事件。

我们在上面/miniprogram/pages/player/player.js 中实现过一个下一首的功能，函数 onNext()。

那么只要在backgroundAudioManager触发了onEnded事件的时候执行onNext就可以实现自动播放了：

```js
// miniprogram/pages/player/player.js
    onLoad: function (options) {
    backgroundAudioManager.onEnded(() => {
      this.onNext() //调用onNext，切换下一首
    })

    console.log(options)
    nowPlayingIndex = options.index
    musiclist = wx.getStorageSync('musiclist')
    this._loadMusicDetail(options.musicId)
  },
```



还可以在进度条组件内部完成这个功能，用到父子组件通讯的方式。进度条组件作为播放器页面的一个子组件，想要调用pleyer.js中的onNext函数，就需要子组件向父组件通讯让父组件调用onNext函数。

```js
      // miniprogram/components/progress-bar/cmp.js 
      backgroundAudioManager.onEnded(() => {
        console.log('onEnded')
        // 自定义组件触发事件
        this.triggerEvent('musicEnd')
      })
```

```html
// miniprogram/pages/player/player.wxml 
<!-- 进度条 -->
<view class="progress-bar">
  <progress-bar  bind:musicEnd="onNext"/>
</view>
```

就是这么简单就实现了，比起第一种方式这种更加规范，有条理，而且减少了功能耦合。



### 歌词显示组件

实现功能：

1. 点击封面时显示歌词，点击歌词时显示封面
2. 



##### 歌词与封面的切换

老样子新建`/miniprogram/components/lyric/cmp`

/miniprogram/pages/player/player.json 进行组件的注册引入👇	

```json
{
  "usingComponents": {
    "progress-bar": "../../components/progress-bar/cmp",
    "lyric": "../../components/lyric/cmp"
  }
}
```

然后在/miniprogram/pages/player/player.wxml 中引用就有了。



封面和歌词组件都绑定一个点击事件，触发函数onChangeLyricShow修改变量isLyricShow，而这个变量决定封面和歌词的切换。

```h&#39;t&#39;m
<view class="player-disc {{isPlaying?'play':''}}" bindtap="onChangeLyricShow" hidden="{{isLyricShow}}">

...

<!-- 歌词组件 -->
<lyric isLyricShow="{{!isLyricShow}}" bindtap="onChangeLyricShow"/>
```

```html
<!--components/lyric/cmp.wxml-->
<scroll-view hidden="{{isLyricShow}}">
歌词
</scroll-view>

```

```js
  onChangeLyricShow(){
    this.setData({
      isLyricShow: !this.data.isLyricShow
    })
  },
```



##### 加载歌词之云函数music更新

```js
  // 加载歌词数据
  app.router("lyric", async(ctx, next)=>{
    ctx.body = await rp(BASE_URL+`/lyric?id=${event.musicId}`).thne(res=>{
      return res
    })
  })
```



##### 调用云函数获取歌词并保存

```js
// 在关闭加载动画后

      // 加载歌词
      wx.cloud.callFunction({
        name: 'music',
        data:{
          musicId,
          $url: 'lyric'
        }
      }).then(res=>{
        console.log(res)
        let lyric = '暂无歌词'
        const lrc = JSON.parse(res.result).lrc
        if(lrc){
          lyric = lrc.lyric
        }
        this.setData({
          lyric: lyric
        })
      })
```

将/miniprogram/pages/player/player.js 中的lyric数据传给歌词组件👇

```html
<!-- 歌词组件 -->
<lyric isLyricShow="{{!isLyricShow}}" bindtap="onChangeLyricShow" lyric="{{lyric}}"/>
```

在歌词组件的js文件中👇

```js
  properties: {
    isLyricShow:{
      type: Boolean,
      value: false
    },
    lyric: String,
  },

  observers: {
    lyric(lrc){
      console.log(lrc)
    }
  },

```

打印结果如下，可以一窥歌词数据的摸样👇

![](https://pic2.zhimg.com/80/v2-eb4794dbd0df6dbd08489b82185600a8_hd.png)

这样的数据需要做进一步解析。



##### 歌词数据解析

在歌词组件中定义函数，做对歌词数据的解析，其中也包括了对无歌词情况的处理：

```js
    _paresLyric(sLyric) {
      let line = sLyric.split('\n')
      let _lyricList = []
      line.forEach((elem)=>{
        let time = elem.match(/\[(\d{2,}):(\d{2})(?:\.(\d{2,3}))?]/g)
        if(time!=null){
          let lrc = elem.split(time)[1]
          let timeReg = time[0].match(/(\d{2,}):(\d{2})(?:\.(\d{2,3}))?/)
          // 把事件转换为秒
          let time2Seconds = parseInt(timeReg[1]*60)+parseInt(timeReg[2])+parseInt(timeReg[3])/1000
          _lyricList.push({
            lrc,
            time: time2Seconds
          })
        }
      })
      // 有些歌词是空的，上述的解析对其无效，_lyricList仍是空的，则设置为暂无歌词
      if(_lyricList.length==0){
        _lyricList.push({
          lrc: "暂无歌词",
          time: 0
        })
        console.log(_lyricList)
      }
        
      this.setData({
        lrclist: _lyricList
      })
       console.log(this.data.lrclist)
    }
```

数据解析完成后打印出来如下👇

![](https://pic3.zhimg.com/v2-d86e763974f40d002f04ee2c4e51c90e_r.jpg)

接下来就可以使用该数据渲染到页面上。

![](https://pic4.zhimg.com/80/v2-d80136333f400903755e71f850b32f6b_hd.jpg)





##### 歌词联动

之前在进度条组件progress-bar中，`backgroundAudioManager.onTimeUpdate`可以获取到当前时间的秒数`backgroundAudioManager.currentTime`，将其和歌词组件lyric中的当前`lrclist.time`进行比较，若相同则当前的`lrclist.lrc`即为高亮样式。

这样需要进行组件间的通讯，要把进度条组件progress-bar的`backgroundAudioManager.currentTime`传给歌词组件lyric。

这里做的是先把进度条组件progress-bar的`backgroundAudioManager.currentTime`传给调用它的父级——播放器页面player，然后player再将`backgroundAudioManager.currentTime`保存并传给歌词组件lyric，父级播放器页面作为中间人实现了两个子组件之间的通讯。

这里我思路有了问题，我一开始是想要进度条组件progress-bar的`backgroundAudioManager.onTimeUpdate`通过triggerEvent来自定义一个事件让父级player触发，同时把`backgroundAudioManager.currentTime`作为参数传过去，这一步是没有问题的。下一步我想当然的让player触发事件执行函数，把参数存到data中，然后另一个子组件歌词组件中自定义一个属性，属性值为我们保存到data中`backgroundAudioManager.currentTime`，这样歌词组件就获取到了我们想要的数据。**但是！**这种方式是一次性的，随后data的数据随着播放的进行而改变，而歌词组件中保存的永远是一开始的初始数据，它是不会数据联动的。

正确做法如下👇

给歌词组件元素加上一个类名，接下来要获取到它：

```html
/miniprogram/pages/player/player.wxml 
<!-- 歌词组件 -->
<lyric class="lyric" isLyricShow="{{!isLyricShow}}" bindtap="onChangeLyricShow" lyric="{{lyric}}" />
```

在/miniprogram/pages/player/player.js 中通过`this.selectComponent('.lyric')`获取到它。这是我第一次用到自定义组件的[selectComponent](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)方法，使用选择器选择组件实例节点，返回匹配到的第一个组件实例对象。

```js
  timeUpdate(event){
    // console.log(event.detail.currentTime)
    this.selectComponent('.lyric').update(event.detail.currentTime)
  },
```

这里的update方法要在歌词组件lyric中进行定义：

```js
    update(currentTime){
      console.log(currentTime)
    },
```

接下来我们就可以看到随着歌曲的播放，在歌词组件中不断打印出传入的参数currentTime。我们就成功在歌词组件中获取到了当前播放的秒数，所以可以进行下一步的匹配了。

```js
    update(currentTime){
      // console.log(currentTime)
      let lrcList = this.data.lrclist
      if(lrcList.length == 0){ //如果没有歌词纯音乐，直接退出啥也不干
        return
      }
      for(let i = 0, len = lrcList.length; i < len; i++){
        if(currentTime<=lrcList[i].time){
          this.setData({
            nowLyricIndex: i-1
          })
          break // 匹配上了就不用再进行后续的匹配了，节省性能开销
        }
      }
    },
```

样式随着nowLyricIndex而改变👇

```html
<!--components/lyric/cmp.wxml-->

<scroll-view hidden="{{isLyricShow}}" class="lyric-scroll">
  <view class="lyric-panel">
    <block wx:for="{{lrclist}}" wx:key="item">
      <view class="lyric {{index==nowLyricIndex?'hightlight-lyric':''}}">{{item.lrc}}</view>
    </block>
  </view>
</scroll-view>
```

效果如下👇

![](https://pic2.zhimg.com/80/v2-9cb654d2edd0362165b0ceba5ff13875_hd.png)

接下来要解决的就是高亮部分居中不动，歌词向上滚动。

歌词部分是用`scroll-view`包起来的，设置`scroll-top`，`scroll-y`规定纵向滚动，`scroll-with-animation="true"`使滚动有动画效果。不断变化`scroll-top`其值实现滚动效果：

```html
<!--components/lyric/cmp.wxml-->

<scroll-view hidden="{{isLyricShow}}" class="lyric-scroll" scroll-top="{{scrollTop}}" scroll-y>
  <view class="lyric-panel">
    <block wx:for="{{lrclist}}" wx:key="item">
      <view class="lyric {{index==nowLyricIndex?'hightlight-lyric':''}}">{{item.lrc}}</view>
    </block>
  </view>
</scroll-view>

```

```js
// components/lyric/cmp.js
let lyricHeight = 0 

// 组件生命周期
  lifetimes:{
    ready(){
      // wx.getSystemInfo可以获取到当前手机的信息，其中包括屏幕宽度screenWidth
      wx.getSystemInfo({
        success: function(res) {
          // 在小程序中宽度都为750rpx，下面可以求出1rpx对应多少px，再乘以一行歌词的高度64rpx，
          // 即可求出一行歌词有多少px
          lyricHeight = res.screenWidth / 750 * 64
        },
      })
    }
  },
  
```

```js
    update(currentTime){
      // console.log(currentTime)
      let lrcList = this.data.lrclist
      if(lrcList.length == 0){ //如果没有歌词纯音乐，直接退出啥也不干
        return
      }
      for(let i = 0, len = lrcList.length; i < len; i++){
        if(currentTime<=lrcList[i].time){
          this.setData({
            nowLyricIndex: i-1,
            scrollTop: (i-1)*lyricHeight
          })
          break // 匹配上了就不用再进行后续的匹配了，节省性能开销
        }
      }
    },
```

这里的每行歌词在样式中已经写死了64rpx，所以不断累乘就行了。但是scroll-top规定的值单位是px，所以要进行rpx和px的换算。具体如上👆

到这一步，歌词联动基本实现了。


##### 【优化】

很多歌的歌词数据是这样的，比如孙燕姿的《开始懂了》全曲4分32秒，但是歌词数据的最后一行是`[03:58.830] 快乐是选择`，这就导致了一个bug，当我滑动进度条到4分04秒的时候，`currentTime<=lrcList[i].time`的判定不成立，所以后续的setData也不成立，歌词联动失败。

那么就要进行一下优化，当当前时间超过了歌词数据的最后一组的时间的时候，就把nowLyricIndex置为`lrcList.length-1`，直接让最后一组歌词高亮，滚动长度为lrcList.length * lyricHeight

```js
    update(currentTime){
      // console.log(currentTime)
      let lrcList = this.data.lrclist
      if(lrcList.length == 0){ //如果没有歌词纯音乐，直接退出啥也不干
        return
      }
      // 如果当前的时间比歌词数据的最后一组都要大，直接让最后一组歌词高亮，滚动长度为lrcList.length * lyricHeight
      if (currentTime > lrcList[lrcList.length-1].time){
        this.setData({
          nowLyricIndex: lrcList.length-1,
          scrollTop: lrcList.length * lyricHeight
        })
      }
      for(let i = 0, len = lrcList.length; i < len; i++){
        if(currentTime<=lrcList[i].time){
          this.setData({
            nowLyricIndex: i-1,
            scrollTop: (i-1)*lyricHeight
          })
          break // 匹配上了就不用再进行后续的匹配了，节省性能开销
        }else{
          
        }
      }
    },
```



### 【优化】

目前有个bug，我在歌曲列表点击某一首歌，歌曲高亮并播放，但当切换到其他歌曲时，高亮没有跟着变成当前播放的歌曲仍时之前的歌曲，另外当我离开这个歌曲列表页的然后再次进入该歌曲列表页的时候，当前播放歌曲没有显示高亮。

这是因为高亮处理是根据歌曲列表组件musiclist中的`playingId`来判断的。`{{item.id===playingId?'playing':''}}`。每次切换其他歌曲的时候`playingId`没有改变，而离开列表页再次进入的时候`playingId`又变成了默认的-1。

```html
<!--components/musiclist/cmp.wxml-->
<block wx:for="{{musiclist}}" wx:key="id">
  <view class="musiclist-container  {{item.id===playingId?'playing':''}}" bindtap="onSelect" data-musicid="{{item.id}}" data-index="{{index}}" >
    <view class="musiclist-index">{{index+1}}</view>
    <view class="musiclist-info">
      <view class="musiclist-name">{{item.name}}</view>
      <view class="musiclist-singer">{{item.ar[0].name}} - {{item.al.name}}</view>
    </view>
  </view>
</block>
```

所以需要有一个公共的属性`playingId`，·playingId`不能只属于播放列表组件。

开始使用app.js进行公共属性操作👇

app.js是小程序全局的操作，初始状态的app.js👇

```js
//app.js
App({
  onLaunch: function () {
    
    if (!wx.cloud) {
      console.error('请使用 2.2.3 或以上的基础库以使用云能力')
    } else {
      wx.cloud.init({
        // env 参数说明：
        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源
        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看
        //   如不填则使用默认环境（第一个创建的环境）
        env: 'dev-r049g',
        traceUser: true,  //记录小程序的访问者
      })
    }

    this.globalData = {}  //全局属性和方法
  }
})

```

将要用到的全局公共属性定义在`this.globalData`中并定义对其的赋值取值操作：

```js
//app.js
App({
  onLaunch: function () {
    
    if (!wx.cloud) {
      console.error('请使用 2.2.3 或以上的基础库以使用云能力')
    } else {
      wx.cloud.init({
        // env 参数说明：
        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源
        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看
        //   如不填则使用默认环境（第一个创建的环境）
        env: 'dev-r049g',
        traceUser: true,  //记录小程序的访问者
      })
    }

    this.globalData = {
      playingMusicId: -1
    }  
  },
  setPlayingMusicId(musicId){
    this.globalData.playingMusicId = musicId
  },
  getPlayingMusicId(){
    return this.globalData.playingMusicId
  }
})

```

那么如何在页面中获取到app.js的数据呢？

通过`getApp()`获取到：

![](https://pic3.zhimg.com/v2-f960a6739ee917def9070005a3225cfa_r.jpg)

在歌曲加载的时候将当前播放歌曲的id设置为全局的

![](https://pic3.zhimg.com/v2-df18c14bb8cde16802c8c1b4456443c2_r.jpg)

然后在歌曲列表页面每次显示的时候获取该全局的id然后保存为自己的playingId，这里用到了[组件所在页面的生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)。

```js
// components/musiclist/cmp.js
const app = getApp()
...
  pageLifetimes:{
    show(){
      // console.log('我出现了' + app.getPlayingMusicId())
      this.setData({
        playingId: app.getPlayingMusicId()
      })
    }
  },
```

搞定。

**还有一个要优化的点**，当如下图所示通过手机微信自带的控制按钮暂停了歌曲播放，但是小程序播放页里的播放按钮没有跟着改变，封面仍在旋转，指针也没有抬起。这些都是由`/miniprogram/pages/player/player.js `中的`isPlaying`来影响的。这一点需要优化。

<img src="https://pic1.zhimg.com/80/v2-5ac4aae674051ca3f47952f56e49a260_hd.png" style="width:300px" />

<img src="https://pic3.zhimg.com/80/v2-71123a7b248283f7c98fe5320e448a8b_hd.png" style="width:300px" />

这个其实很简单，通过手机微信自带的控制按钮暂停或播放了歌曲播放，也会触发backgroundAudioManager.onPause和backgroundAudioManager.onPlay



![](https://pic2.zhimg.com/v2-283c843098570a6502b90b6ba19faadd_r.jpg)



![](https://pic1.zhimg.com/v2-1ebdd55e42b96ce3fc835d269c5525fc_r.jpg)



![](https://pic2.zhimg.com/v2-60c401d61f2bbb872cb73319530d67a9_r.jpg)

至此搞定。

**还有一个要优化的点。**歌曲列表页点击了某一首歌曲，进入到了播放页并开始播放，返回，回到歌曲列表页，再次点击该歌曲的时候，又重新播放了，这个不好，要让他接着播放而非重头播放。

在播放页`/miniprogram/pages/player/player.js `中添加一个标志位`isSame`，表示要播放的是否为同一首歌曲。

![](https://pic3.zhimg.com/v2-d57aeb2e681fc7c0e4b5dcc1db6406d2_r.jpg)

在每次要载入歌曲信息之前，先判断点击要播的歌曲和旧的当前歌曲是不是同一首，进而变化`isSame`的值。接着通过isSame的值知道是不是同一首歌曲，不是的就停止上一首的播放，并给`backgroundAudioManager`进行一些列新值的赋值。否则不用。

![](https://pic4.zhimg.com/v2-62a3e8c6c42874e4d9a0145541a57703_r.jpg)



![](https://pic1.zhimg.com/v2-bb03d4b7d220387c3c1898b799fe53d0_r.jpg)

到这一步为止基本解决了重新点击歌曲重新播放的问题，但是还有一个bug，就是进度条的总时间又变成了00：00，这一点要解决。

![](https://pic2.zhimg.com/80/v2-40e1c883113d3385b0cda2dd0e996e54_hd.png)

把`isSame`传过去给进度条组件👆👇

```js
  properties: {
    isSame: Boolean
  },
  
    // 组件生命周期
  lifetimes:{
    ready(){
      if(this.properties.isSame&&this.data.showTime.totalTime== '00:00'){
        this._setTime() //重新处理totalTime
      }
      this._getMovableDis()
      this._bindBGMEvent()
    }
  },
```

至此成功解决bug。

# 有个要待优化的点，如果频繁按下一首会出问题

## 5.【乐评动态】功能实现



```
- 该功能类似博文发布
- 小程序用户信息授权流程
- 多文件上传云存储异步操作
- 云数据库模糊查询、索引查询、权限查询
```

### 头部

先配置一下blog.json里面的` "navigationBarTitleText": "动态"`，这样点击到动态页时上方就显示对应的动态二字。相应的其他两个tabbar页面也要改一下。

这里要做的头部用到两个icon图标，所以我找了两个icon，更新了一下我的iconfont项目，并把新生成的iconfont.css更新到了小程序项目中。具体操作在音乐播放器控件那里有讲。

之前在音乐播放控件那里使用icon图片使用的时`text`标签，这里还可以使用`<i>`标签👇

```html
<!--miniprogram/pages/blog/blog.wxml-->
<view class="container">
  <!-- 头部 -->
  <view class="header">
    <view class="publish-container" bindtap="onPublish">
      <i class="iconfont icon-fabu"></i>
    </view>
    <view class="search-container"></view>
  </view>

</view>
```

### 搜索组件

```html
<!--components/search/cmp.wxml-->
<view class="container">
  <input class="bar" placeholder="{{placeholder}}" placeholder-class="in-bar"></input>
  <button size="mini" class="search">搜索</button>
</view>
```

这里遇到了一个小程序的坑。小程序上按钮样式button: not([size='mini'])造成按钮样式错乱👇

![](https://pic4.zhimg.com/80/v2-b448a7717144dc56cf0e471e848588df_hd.jpg)

这时小程序新版中app.json里"style": "v2"造成的，所以要么把这个"style": "v2"删去，要么就乖乖在button上加上`size="mini"`。就可以正常地设置button的宽度👇

![](https://pic3.zhimg.com/80/v2-38223bc0438105220403e73234aa088e_hd.jpg)

另外这里的placeholder我没有写死，通过properties来控制，外界有传值过来就用传过来的值，没有的话就用默认值“请输入关键字”👇

```js
// miniprogram/components/search/cmp.js   
properties: {
    placeholder: {
      type:String,
      value: "请输入关键字"
    }
  },
```

#### 组件内引入iconfont

上面的搜索框我要在里面加一个放大镜的icon，我尝试直接像之前那样子操作，直接用一个`i`标签引入👇

```html
<!--components/search/cmp.wxml-->
<view class="container">
  <i class="iconfont icon-sousuo"></i>
  <input class="bar" placeholder="{{placeholder}}" placeholder-class="in-bar"></input>
  <button size="mini" class="search">搜索</button>
</view>
```

但是这是无效的，因为组件会屏蔽外界的css样式，这就是[组件样式隔离](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html#%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB) 。所以说全局作用下的iconfont.wxss是作用不到该组件的。那么我可以复制一个一模一样的iconfont.wxss到组件文件夹中，然后在组件的cmp.wxss中通过@import 'iconfont.wxss'引入新的iconfont.wxss这样就行了。

还有另一种方法👇

#### 外部样式类

上面的方法简单粗暴，但是要多建一个相同的wxss文件。

小程序中有个【[外部样式类](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html#%E5%A4%96%E9%83%A8%E6%A0%B7%E5%BC%8F%E7%B1%BB)】的功能。

```html
<!--miniprogram/pages/blog/blog.wxml-->
<view class="container">
  <!-- 头部 -->
  <view class="header">
    <view class="publish-container" bindtap="onPublish">
      <i class="iconfont icon-fabu"></i>
    </view>
    <view class="search-container">
      <!-- 使用外部样式类的方式传给组件外部的样式类   等号左边随便命名，右边必须是目标类名 -->
      <search-cmp iconfont="iconfont" icon-sousuo="icon-sousuo"/>
    </view>
  </view>

</view>
```

```js
// miniprogram/components/search/cmp.js   
// 记录外部传入的外部样式类
  externalClasses:[
    "iconfont",
    "icon-sousuo"
  ],
```

然后wxml中这样写就奏效了👇

```html
  <i class="iconfont icon-sousuo"></i>
```

【注意】传进来的外部样式类是不可以修改的。所以如果想要在此基础上添加新的样式，建议另外写一个样式类。

### 底部弹出层

功能：当用户点击发布按钮要发布动态的时候，或在发布评论的时候，都会弹出一个底部弹出层，要求获取用户的微信信息。

处于复用性考虑，将底部弹出层封装成一个组件。

/miniprogram/components/bottom-layer/cmp.wxml 👇

```html
<view class="layer" hidden="{{!layerShow}}">
  <view class="panel">
    <i class="iconfont icon-shanchu" bindtap="onClose"></i>
    <!-- slot插槽  具名插槽 -->
    <slot name="layer-content"></slot>
  </view>
</view>
```

这里又要用到外部的样式类了，这次是icon-shanchu。

这次用个新的解决方式👇

#### styleIsolation处理组件样式隔离

前面讲了默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。这里介绍一个新的解决方法——指定特殊的样式隔离选项 `styleIsolation` 。

```js
// miniprogram/components/bottom-layer/cmp.js  
options:{
    styleIsolation: 'apply-shared'
  },
```

`apply-shared` 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面。

这个比之前两种方法都简便，但是请务必注意组件间样式的相互影响。

**至此已经介绍了三种处理组件样式隔离的方法：**

1. 组件内新建和外部样式一样的样式代码
2. 使用外部样式类externalClasses，组件内不能修改外部引入的样式类
3. 使用styleIsolation，设置为`apply-shared`的时候 组件内可以修改外部引入的样式类。



#### 使用固定定位充满屏幕

```html
<view class="layer">
  <view class="panel">
    <i class="iconfont icon-shanchu"></i>
  </view>
</view>
//miniprogram/components/bottom-layer/cmp.wxml 
```

通过styleIsolation设置的外部样式类可以在组件内进行修改👇

```css
.layer{
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* 这上面五行代码是为了让layer层铺满整个屏幕，写弹窗效果时经常会这样用 */

  z-index: 99;
  text-align: center;
  background: rgba(0, 0, 0, .6);
}
.panel{
  position: absolute;
  bottom: 0rpx;
  left: 0;
  height: 300rpx;
  width: 100%;
  background-color: #f8f8f8f8;
}

/* 通过styleIsolation设置的外部样式类可以在组件内进行修改 */
.layer .icon-shanchu{
  position: absolute;
  right: 0;
  top: 10rpx;
  padding: 20rpx;/*为了增加可点击区域大小*/
}
//miniprogram/components/bottom-layer/cmp.wxss 
```

![](https://pic2.zhimg.com/80/v2-9dfaba851e00b7100a4074b28762070f_hd.png)



	#### 使用slot插槽

slot插槽👉[点击](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html#%E7%BB%84%E4%BB%B6wxml%E7%9A%84slot)

关于整个底部弹出层，我们不想直接写死了里面的内容，希望把弹出层的内容通过组件使用者来传入，所以这里要 使用`slot` 节点，用于承载组件使用者提供的wxml结构。

这里我使用了多个插槽，所以要使用**具名插槽**。



#### 授权组件login 	

我想要在这个底部弹出层进行微信授权确认，这里封装一个授权组件。只有在获取到微信授权的情况下才能进行动态发布和评论。

👉关于[微信小程序授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)

这里的授权组件内部会调用上面写好的底部弹出层组件，所以之前我们在blog页面调用底部弹出层组件的做法就不要了，改成在blog页面调用login授权组件，而这个login授权组件内部调用底部弹出层组件。

**这里看一下blog、login和bottom-layer这三部分的代码，涉及到插槽的使用和组件间传值，比较杂就不展开做笔记。**

效果如下👇

![](https://pic2.zhimg.com/80/v2-f2285b46130dd8fe8083bf3d60b05eb5_hd.png)

接下来要实现点击“获取微信授权信息”调用微信小程序授权api实现授权的功能。

```html
<!--components/login/cmp.wxml-->
<bottom-layer layerShow="{{show}}">
  <view slot="layer-content">
    <button class="login" 
            open-type="getUserInfo"
            >获取微信授权信息</button>
  </view>
</bottom-layer>
```

这里的button写上了`open-type`属性，其值为`getUserInfo`，这样点击该按钮的时候就会弹出小程序索取用户授权的弹窗👇

![](https://pic4.zhimg.com/80/v2-9e88fc5514cf543d09f5f99afe0f9619_hd.png)

用户点击允许按钮之后小程序会获取到了微信授权。我们再给button加多一个事件`bindgetuserinfo`👇

![](https://pic4.zhimg.com/80/v2-5bd38d61d9b3fa84955cc47270e61b07_hd.png)

在其对应的cmp.js中实现这个`onGotUserInfo`👇

```js
  methods: {
    onGotUserInfo(event){
      console.log(event)
    }
  }
```

看看这个event里都有啥信息👇

![](https://pic2.zhimg.com/v2-7226e1dd8884b23580b74f98968d5e45_r.jpg)

可以看到，我们可以获取到用户的微信信息。

进一步完善👇

获得授权后关闭弹出层、传递用户信息给父级的blog：

![](https://pic4.zhimg.com/80/v2-a5466b21cf9251e35d2e460d25de066d_hd.png)

对应的父级blog👇

```html
  <!-- 授权组件底部弹出层 -->
<login-cmp show="{{show}}"
           bind:loginsuccess="onLoginSuccess"
           bind:loginfail="onLoginFail">
           
 // miniprogram/pages/blog/blog.wxml 
```

![](https://pic3.zhimg.com/80/v2-420af70cb910b0ac85ca1980abe94d1c_hd.png)

![](https://pic3.zhimg.com/80/v2-3586021a9e24b96dee6d5718fc78151e_hd.png)

在编辑页面的blog-edit/cmp.js中就可以得到传过来的 信息👇

```js
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log(options)
  },
```

控制台打印输出传过来的用户昵称和头像。



### 博文编辑和发布页面

编辑部分用了原生组件`textarea`这个原生组件。

```html
<!--pages/blog-edit/blog-edit.wxml-->
<view class="container">
  <textarea class="content" 
            placeholder="分享你的乐评叭~"
            bindinput="onInput"
            maxlength="140"
            auto-focus></textarea>

  <view class="image-list">
    <!-- 显示图片 -->

    <!-- 选择图片 -->
    <view class="image-wrap selectphoto">
      <i class="iconfont icon-add-fill"></i>
    </view>
  </view>
</view>

<view class="footer">
  <text class="words-num">{{wordsNum}}</text>
  <button size="mini" class="send-btn">发布</button>
</view>
```

textarea作为原生组件不允许使用`bind：xxx`的格式，智能使用`bindxxx`的格式，关于原生组件还有其他限制，见下文。

![](https://pic2.zhimg.com/80/v2-e52b97255945ec186770da8790245415_hd.png)

![](https://pic4.zhimg.com/80/v2-70d22b11f7dfc15f2d7b453322379c15_hd.png)





#### 原生组件的限制

关于原生组件👉[点击](https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html)

要特别注意。



#### 聚焦键盘弹出时footer上移，失去焦点时恢复

这个footer是有实时显示输入的字数的，textarea聚焦**（bindfocus）**键盘弹出的时候我希望footer上移到键盘上头，失去焦点**（bindblur）**的时候恢复原来位置。

auto-focus 自动聚焦。

```html
  <textarea class="content" 
            placeholder="分享你的乐评叭~"
            bindinput="onInput"
            bindfocus="onFocus"
            bindblur="onBlur"
            maxlength="140"
            auto-focus
            ></textarea>
```

聚焦的时候获取键盘占用的高度，将这个高度值赋给footer的bottom值，这样就可以使得footer被弹起。

```html
<view class="footer" style="bottom:{{footerBottom}}px">
  <!-- 内联样式的bottom，配合聚焦上移的动作；  注意px不要漏了 -->
  <text class="words-num">{{wordsNum}}</text>
  <button size="mini" class="send-btn">发布</button>
</view>
```

```js
  onFocus(event){
    console.log(event)
    this.setData({
      footerBottom: event.detail.height //这个高度就是键盘占用的高度
    })
   }, 

  onBlur(){
    this.setData({
      footerBottom: 0
    })
  },
```

<img src="https://pic4.zhimg.com/80/v2-932d43b4b9be838fa521f6ba7c487dc0_hd.png" style="width:300px" />



### 选择图片业务

点击➕选择上传的图片

这里要用到一个api--》[wx.chooseImage](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseImage.html)

```html
// miniprogram/pages/blog-edit/blog-edit.wxml 
<view class="image-list">
    <!-- 显示图片 -->
    <block wx:for="{{images}}" wx:key="*this">
      <view class="image-wrap">
        <image class="image" src="{{item}}" mode="aspectFill"></image>
        <i class="iconfont icon-shanchu" bindtap="onDelImage" data-index="{{index}}"></i>
      </view>
    </block>
    <!-- 选择图片 -->
    <view class="image-wrap selectphoto" 
          bindtap="onChooseImage"
          hidden="{{!selectPhoto}}">
      <i class="iconfont icon-add-fill"></i>
    </view>
  </view>
```

这里使用了flex布局，自动换行`flex-wrap: wrap`，每行显示三个。

![](https://pic4.zhimg.com/80/v2-8c58f12ccee753241a36151705cccb9f_hd.png)



在使用wx.chooseImage的时候，会给每张图片生成一个**临时路径**用以唯一标识对应的图片，即下图中的`res.tempFilePaths`。

![](https://pic1.zhimg.com/v2-c5afd560c89a83ddb62b311965dc9d8c_r.jpg)

最多只能传9张，选择超过9张的只取前9张，并且隐藏添加按钮，点击❌可以删除，一旦删除必定恢复添加按钮。

#### 图片预览功能

这就要用到新的api👉 **[wx.previewImage](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html)**

给图片绑定一个点击事件，触发onPreivewImage函数👇

```html
<image class="image" src="{{item}}" 
               mode="aspectFill" 
               data-imgsrc="{{item}}"
               bindtap="onPreivewImage"></image>
```

```js
  // 图片预览功能
  onPreivewImage(event){
    wx.previewImage({
      urls: this.data.images,
      current: event.target.dataset.imgsrc,
    })
  },
```







### 发布功能——多文件上传云存储

给发布按钮绑定点击事件，将数据上传到云数据库中，实现数据的持久化。这个云数据库是一个非关系型的数据库，用json格式存储数据。

对于我们这个发布功能，数据包括文字内容和图片，其中图片被存在云存储中，微信小程序云开发技术**云存储**中提供了许多api供开发者使用，包括上传文件、下载文件、删除文件、获取文件链接等。

上传文件到云存储后，会获得一个云文件ID`fileID`，作为文件的唯一标识。当我们要使用云存储中的某个数据的时候，就可以通过`fileID`获取到，而这个`fileID`则被我们存储在**云数据库**中。

**之后可以将`fileID`的值赋给`image`标签的src值，就能显示图片了，但是直接在浏览器中访问时访问不到的，很神奇，我后面写乐评部分的时候才发现的。**

我们还需要知道每条动态是哪个用户发布的，所以云数据库中还要存储标识用户的`openid`（**注意：openid会自动生成所以不用手动存入）**、用户昵称、用户头像、发布时间

所以关系是这样子的👇:

先将图片上传到云存储得到`fileID`，然后将`fileID`和其他数据一起存入云数据库

![](https://pic2.zhimg.com/80/v2-9f148ecb76cc86a457f37c73b0fd4d7e_hd.png)



#### 上传图片至云存储

用到的api👉 [wx.cloud.uploadFile](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/uploadFile/client.uploadFile.html)

wx.cloud.uploadFile每次只能上传一张，所以需要循环遍历图片列表，每次循环都上传一张。

我们现在云存储中新建一个文件夹，我命名为blog，这些图片我都打算存在这个blog中。

- 需要使用正则表达式得到每张图片的后缀名
- cloudPath必须做到唯一化，避免重名导致的资源覆盖

```js
  // 发布功能
  send(){
    // 数据 ——> 云数据库
    for(let i = 0; i<this.data.images.length; i++){
      let item = this.data.images[i]
      // 使用正则表达式截取到每张图片的后缀名
      let suffix = /\.\w+$/.exec(item)[0]
      
      wx.cloud.uploadFile({
        cloudPath: 'blog/' + Date.now() + '-' + Math.random() * 1000000 + suffix, //云存储路径，必须先存在，这里做了唯一化，避免重名导致的资源覆盖
        filePath: item,  // filePath表示上传文件资源的路径
        success: (res)=>{
          console.log(res)  // 返回的res中有fileID
        },
        fail: (err)=>{  
          console.log(err)
        }
      })
    }
  },
```

图片发布后我们可以在云存储中看到👇

![](https://pic1.zhimg.com/v2-91afe198cbd27fc461b79a038f3daf0c_r.jpg)

可以看到每张图片都成功存入了云存储中，并生成了`flieID`。我们右键还可以查看详情，里面有每张图片的永久链接（下载地址）、生成时间等等信息。



#### 数据插入云数据库

上文我们成功将图片存入云存储中，这个过程是一个异步的过程，我们需要在所有图片都存入云存储中之后才将所有的`fileID`以及其他数据插入云数据库中。这里就要用到**promise.all**

```js
  // miniprogram/pages/blog-edit/blog-edit.js 

  // 发布功能
  // 图片数据 ——> 云存储   fileID ——>云数据库
  send(){

    if(content.trim()===''){
      wx.showModal({
        title: '请写点什么吧~',
        content: '',
      })
      return 
    }
    //👆文本为空不允许，文本不为空才执行下面的程序👇

    wx.showLoading({
      title: '发布中',
    })

    let promiseArr = []  //用于存储每个Promise对象
    let fileIds = []  // 用于存储fileID
    for(let i = 0; i<this.data.images.length; i++){
      let p = new Promise((resolve, reject)=>{  //将每次的上传操作都封装成promise
        let item = this.data.images[i]
        // 使用正则表达式截取到每张图片的后缀名
        let suffix = /\.\w+$/.exec(item)[0]

        wx.cloud.uploadFile({
          cloudPath: 'blog/' + Date.now() + '-' + Math.random() * 1000000 + suffix, //云存储路径，必须先存在，这里做了唯一化，避免重名导致的资源覆盖
          filePath: item,  // filePath表示上传文件资源的路径
          success: (res) => {
            // console.log(res)  // 返回的res中有fileID
            fileIds = fileIds.concat(res.fileID) //每次上传成功就添加fileID到数组中
            resolve()
          },
          fail: (err) => {
            console.log(err)
            reject()
          }
        })
      })
      
      promiseArr.push(p) 
    }

    // fileID存入云数据库
    Promise.all(promiseArr).then(res=>{
      db.collection('blog').add({
        data:{
          ...userInfo,
          content,
          img: fileIds,
          createTime: db.serverDate(),  //服务器时间  
        }
      }).then(res=>{
        wx.hideLoading()
        wx.showToast({
          title: '发布成功',
        })

        // 返回动态页面，并刷新
        wx.navigateBack()

        
      }).catch(err=>{
        wx.hideLoading()
        wx.showToast({
          title: '发布失败，请检查您的网络',
        })
      })
    })

  },
```

接下来要做的就是动态页面的显示和刷新。



### 博客卡片组件与云函数加载数据

#### 云函数blog

在乐评动态这里的每个博文动态都通过博客卡片组件来显示，需要封装博客卡片组件。

在此之前先新建一个云函数blog，和之前的云函数music一样，依旧是使用tcb-router进行路由优化，安装tcb-router👇

```
npm install tcb-router --save
```

云函数blog中实现list路由用以获取博文数据👇

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

const TcbRouter = require('tcb-router')
const db = wx.cloud.database()
const blogCollection = db.collection('blog')

// 云函数入口函数
exports.main = async (event, context) => {
  const app = new TcbRouter({
    event
  })

  app.router('list', async (ctx, next)=>{
    let blogList = await blogCollection.skip(event.start)
                    .limit(event.count)
                    .orderBy('createTime','desc')
                    .get()
                    .then(res=>{
                      return res.data
                    })
    ctx.body = blogList //返回数据
  })

  return app.serve
}
```

之后上传部署到云端。



#### blog页面调用云函数blog加载数据

![](https://pic1.zhimg.com/80/v2-d4a6f83bcba7a8dada78cf177a94114c_hd.png)

这里暂且定为`start: 0, count: 10`，之后要改的。

这样每次进入blog页面就加载了数据库中的数据。

到数据后接下来要做的是渲染页面。



#### 博客卡片组件

blog页面中遍历数据，使用博客卡片组件blog-card：

```html
  <!-- 博客卡片 -->
  <view class="blog-list">
    <block wx:for="{{blogList}}" wx:key="_id">
      <view class="blog-panel">
        <blog-card blog="{{item}}"  />
      </view>
    </block>
  </view>
```



```html
<!--components/blog-card/cmp.wxml-->
<view class="blog">
  <!-- 昵称、头像、发布时间 -->
  <view class="blog-title">
    <image class="blog-portrait" src="{{blog.avatarUrl}}"></image>
    <view class="blog-box">
      <view>{{blog.nickName}}</view>
      <view class="blog-time">{{blog.createTime}}</view>
    </view>
  </view>
  <!-- 博文内容、图片 -->
  <view class="blog-content" style='white-space:pre-wrap'>{{blog.content}}</view>
  <view class="blog-img">
    <block wx:for="{{blog.img}}" wx:key="{{index}}">
      <image class="img" src="{{item}}" mode="aspectFill"></image>
    </block>
  </view>
</view>
```



这里有个要注意的，微信小程序`<text>`和`<view>`标签并不能让文本自动换行，这导致了我文本中的一些换行无法显示出来，微信小程序也不支持 `<br/>`换行。

处理方法：

```html

```

![](https://pic2.zhimg.com/80/v2-473c285c7a0be119ff6d0ad238772670_hd.png)

这里大体上的样式没毛病了，但是时间这里要格式化成我们习惯的格式。



#### 格式化时间

在utils文件夹新建一个formatTime.js文件，用以专门格式化时间。

```js
module.exports = (date)=>{
  let fmt = 'yyyy-MM-dd hh:mm'
  const o = {
    'M+': date.getMonth()+1,  // 月份 date.getMonth()值为0~11，所以要加1
    'd+': date.getDate(),     // 日
    'h+': date.getHours(),    // 时 
    'm+': date.getMinutes(),  // 分
  }

  if(/(y+)/.test(fmt)){
    fmt = fmt.replace(RegExp.$1, date.getFullYear())
  }
  for(let k in o){
    if(new RegExp('(' + k + ')').test(fmt)){
      // o[k].toString().length == 1判断是不是0~9，是的话前面要补零
      fmt = fmt.replace(RegExp.$1, o[k].toString().length==1 ? '0'+o[k] : o[k])
    }
  }
  return fmt
}
```



在博客卡片组件中使用这个格式化功能，有两种方法：一种是在组件生命周期attached时格式化，另一种时通过observers格式化：

```js
// components/blog-card/cmp.js

// 引入格式化时间的js文件
import formatTime from '../../utils/formatTime.js'
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    blog: Object
  },

  lifetimes:{
    attached(){
      // console.log(this.properties.blog)
      let createTime = new Date(this.properties.blog.createTime)  // 要记得先new Date
      let fmt = formatTime(createTime)
      this.setData({
        _createTime: fmt
      })
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    _createTime: ''
  },

  /**
   * 组件的方法列表
   */
  methods: {
  }
})

```



```js
// components/blog-card/cmp.js

// 引入格式化时间的js文件
import formatTime from '../../utils/formatTime.js'
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    blog: Object
  },

  observers: {
    ['blog.createTime'](val){
      if(val){
        this.setData({
          _createTime: formatTime(new Date(val))  // 要记得先new Date
        })
      }
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    _createTime: ''
  },

  /**
   * 组件的方法列表
   */
  methods: {
  }
})

```



#### 上滑下拉加载更多

对进行修改：

```js
  _loadBlogList( start = 0 ){ // start变成了一个参数，默认为0
    wx.showLoading({
      title: '加载中',
    })
    wx.cloud.callFunction({
      name: 'blog',
      data:{
        start,
        count: 10,
        $url: 'list',
      }
    }).then(res=>{
      console.log(res)
      this.setData({
        blogList: this.data.blogList.concat(res.result)
      })
      wx.hideLoading()
      wx.stopPullDownRefresh()  //这步不写的话真机不会回弹页面
    })
  },
```

```js
  onPullDownRefresh: function () {
    this.setData({
      blogList: []
    })
    this._loadBlogList(0)
  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    this._loadBlogList(this.data.blogList.length)
  },
```



#### 图片预览

和之前的发布动态时的预览图片差不多，依旧是使用wx.previewImage()

```js
    onPreviewImage(event){
      console.log(event)
      wx.previewImage({
        urls: this.properties.blog.img,
        current: event.currentTarget.dataset.index
      })
    },
```

另外我还高了一个头像预览：

```js
    onPreviewAvatar(event){
      console.log(event)
      wx.previewImage({
        urls: [].concat(this.properties.blog.avatarUrl)
      })
    }
```

这里有个有意思的事，这个用户头像的url是在用户要发布动态是通过微信授权wx.getUserInfo得到的。用户头像图片的 URL。URL 最后一个数值代表正方形头像大小（有 0、46、64、96、132 数值可选，0 代表 640x640 的正方形头像，46 表示 46x46 的正方形头像，剩余数值以此类推。默认132），用户没有头像时该项为空。若用户更换头像，原有头像 URL 将失效。

默认132的图片预览看起来太模糊了，于是我改了一下/miniprogram/pages/blog/blog.js 中的onLoginSuccess()

，手动把url末尾的'/132'改成了’/0‘，这样就是高清原图 了。



#### 博文详情

点击博文跳转到博文详情中，可以看到评论。

绑定一个点击事件触发goComment函数，同时自定义一个属性`data-blogid`用以保存并传递当前博文的`_id`，博文详情页就可以通过这个`blogid`向云数据库获取到数据。

```html
  <!-- 博客卡片 -->
  <view class="blog-list">
    <block wx:for="{{blogList}}" wx:key="_id">
      <view class="blog-panel">
        <blog-card blog="{{item}}"
                   data-blogid="{{item._id}}"
                   bindtap="goComment" />
      </view>
    </block>
  </view>
```

```js
  goComment(event){
    console.log(event)
    wx.navigateTo({
      url: '../../pages/blog-comment/blog-comment?blogId='+event.target.dataset.blogid,
    })
  },
```

但是由于事件冒泡的影响，当我点击图片想要预览的时候，也触发了跳转到详情页的事件。所以要把之前头像预览和图片预览时使用的`bindtap`改成`catchtap`。这样就解决了事件冒泡。



### 【优化】

一、发布动态的时候加上蒙板效果，避免用户多次点击发布按钮，这一点小程序的showloading提供了一个mask选项，非常便捷。

/miniprogram/pages/blog-edit/blog-edit.js  👇

```js
    wx.showLoading({
      title: '发布中',
      mask: true,  //有蒙板效果
    })
```



二、发布动态后自动刷新乐评博客动态页面

​	![](https://pic1.zhimg.com/80/v2-5f6a5145640977926e83debd451b7154_hd.png)

我们需要在这里做些操作。我们想要页面返回到blog页面，然后重新刷新页面，这个操作可以调用blog的上拉刷新的函数。那么要如何在blog-edit页面调用blog页面的函数呢？这就要用到[getCurrentPages](https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html)，获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。

先来看看这个页面栈长啥样👇

![](https://pic1.zhimg.com/v2-335827d0a48555dc9584de2ee13c85ac_r.jpg)

这样在blog-edit页面就可以拿到blog页面的实例了，进而可以调用blog的上拉刷新函数👇



### 【重大bug】实现图片不乱序

由于图片在上传的时候使用的是promise.all，各个promise之间没有严格的先后顺序，导致图片的顺序乱了！！！

所以是不可以用异步的方式来上传多张图片的，需要用**递归**的方式！

```js
  // 发布功能
  // 图片数据 ——> 云存储   fileID ——>云数据库
  send() {

    if (content.trim() === '') {
      wx.showModal({
        title: '请写点什么吧~',
        content: '',
      })
      return
    }
    //👆文本为空不允许，文本不为空才执行下面的程序👇

    wx.showLoading({
      title: '发布中',
      mask: true,  //有蒙板效果
    })

    let imagesObj = {}
    imagesObj.urlList = this.data.images //this.data.images是由所有已选图片url组成的数组
    let fileIds = []  // 用于存储fileID
    this.uploadimg(imagesObj, fileIds)


  },


  uploadimg(imgObj, fileIds) {
    var that = this,
      i = imgObj.i ? imgObj.i : 0,//当前上传的哪张图片
      success = imgObj.success ? imgObj.success : 0,//上传成功的个数
      fail = imgObj.fail ? imgObj.fail : 0;//上传失败的个数

    let item = imgObj.urlList[i]
    // 使用正则表达式截取到每张图片的后缀名
    let suffix = /\.\w+$/.exec(item)[0]
    
    wx.cloud.uploadFile({
      cloudPath: 'blog/' + Date.now() + '-' + Math.random() * 1000000 + suffix, //云存储路径，必须先存在，这里做了唯一化，避免重名导致的资源覆盖
      filePath: imgObj.urlList[i],
      success: (res) => {
        success++;//图片上传成功，图片上传成功的变量+1
        console.log(res)
        fileIds = fileIds.concat(res.fileID) //每次上传成功就添加fileID到数组中
        console.log(i);
        //这里可能有BUG，失败也会执行这里,所以这里应该是后台返回过来的状态码为成功时，这里的success才+1
      },
      fail: (res) => {
        fail++;//图片上传失败，图片上传失败的变量+1
        console.log('fail:' + i + "fail:" + fail);
        wx.hideLoading()
        wx.showToast({
          title: '图片上传失败',
          icon: 'none'
        })
      },
      complete: () => {
        console.log(i);
        i++;//这个图片执行完上传后，开始上传下一张
        if (i == imgObj.urlList.length) {   //当图片传完时，停止调用          
          console.log('执行完毕');
          console.log('成功：' + success + " 失败：" + fail);

          if(fail===0&&success===imgObj.urlList.length){ //全部上传成功时，进行数据存入云数据库
            console.log(fileIds)
            // fileID存入云数据库
            db.collection('blog').add({
              data: {
                ...userInfo,
                content,
                img: fileIds,
                createTime: db.serverDate(),  //服务器时间  
              }
            }).then(res => {
              wx.hideLoading()
              wx.showToast({
                title: '发布成功',
              })

              // 返回动态页面，并刷新
              wx.navigateBack()
              const pages = getCurrentPages()
              console.log(pages)
              const pervPage = pages[pages.length - 2] //拿到上一页面的实例
              pervPage.onPullDownRefresh() //调用上一页面的上拉刷新函数

            }).catch(err => {
              wx.hideLoading()
              wx.showToast({
                title: '发布失败，请检查您的网络',
                icon: 'none'
              })
            })
          }
        } else {//若图片还没有传完，则继续调用函数
          console.log(i);
          imgObj.i = i;
          imgObj.success = success;
          imgObj.fail = fail;
          that.uploadimg(imgObj, fileIds);
        }

      }
    });

  },
```



### 云数据库模糊查询与索引管理

在搜索框和按钮绑定事件👇

```html
<!--components/search/cmp.wxml-->
<view class="container">
  <i class="iconfont icon-sousuo find"></i>
  <input class="bar" 
         placeholder="{{placeholder}}" 
         placeholder-class="in-bar"
         bindinput="onInput"></input>
  <button size="mini" class="search" bindtap="onSearch">搜索</button>
</view>
```

```js
  methods: {
    onInput(event){
      console.log(event)
      keywords = event.detail.value
    },


    onSearch(){
      console.log(keywords)
    },
  }
```

获取到输入的关键字接下来就是发起对数据库的查询了，这一步不要写在search这个组件中，最好写在blog中，让search组件向blog发起查询操作，这样分离业务比较合理。

![](https://pic4.zhimg.com/80/v2-1a492d111c3da0c7cc452ece7f6ea54f_hd.jpg)

![](https://pic4.zhimg.com/v2-9b004c552718361111b10884d3bf3e1f_r.jpg)

/miniprogram/pages/blog/blog.js 👇

```js
  onSearch(event){
    console.log(event.detail.keyword)
    // 我们搜索出结果的时候，首先清空blogList
    this.setData({
      blogList: [],
    })
    keyword=event.detail.keyword
      //重新加载博客页面
    this._loadBlogList(0)
  },
```

这里我们就要重新改造一下_loadBlogList这个函数了，需要把keyword也作为调用云函数blog的一个参数传入👇

![](https://pic3.zhimg.com/v2-e252c803cb75b12c749f4a395804fffa_r.jpg)

进而云函数blog也要进行有关对云数据库模糊查询的修改👇

这里使用了**云开发的正则表达式**

![](https://pic3.zhimg.com/v2-9b8ed2d647a69012f846320b88bbb43e_r.jpg)

效果👇

![](https://pic1.zhimg.com/80/v2-0fb16305ce2888387999c03ce79bf2bd_hd.png)



#### 添加索引优化搜索速度

![](https://pic2.zhimg.com/v2-25a391f5c87f36f73b6af46d3bed236d_r.jpg)

这样给content字段添加索引，可以优化搜索速度。



### 云数据库权限管理

![](https://pic1.zhimg.com/v2-855598f6fa06f9fa858e0618d02e8ce4_r.jpg)

以上是云数据库的权限管理，默认是仅有创建者可读写，记得修改成所有用户可读，仅创建者可读写。



另外，对于云数据库的操作都放在云函数中进行，不要在小程序端进行，有坑，比如小程序端读取数据只能读取20条。



## 6.评论与分享

```
- 云数据库中1对N关系的三种设计方式
- 云调用实现模板消息推送
- 云数据库多集合查询
- 博客分享给好友
```

### 博客控制组件

这个控制组件包括**评论功能**和**分享功能**。

用户点击评论的时候，我们要先判断用户是否已经授权过，只有授权过的才可以进行评论。这里可以复用前面封装过的**login授权组件**。授权过后，用户进行输入评论的内容，这部分我们使用的之前的**底部弹出层组件**。



新建组件👉/miniprogram/components/blog-ctrl/cmp.wxml 

要在blog.json引入而非在blog-card中引入。

```json
  "usingComponents": {
    "search-cmp": "../../components/search/cmp",
    "login-cmp": "/components/login/cmp",
    "blog-card": "/components/blog-card/cmp",
    "blog-ctrl": "/components/blog-ctrl/cmp"
  },
```



这里又更新了两个新图标，评论和分享，老样子在iconfont官网上找，然后更新项目中iconfont.css样式代码。

```html
// miniprogram/components/blog-ctrl/cmp.wxml 
<view class="ctrl">
  <view class="ctrl-item" bindtap="onComment">
    <i class="iconfont icon-pinglun icon"></i>
    <text>评论</text>
  </view>
  <view class="ctrl-item share">
    <i class="iconfont icon-fenxiang icon"></i>
    <text>分享</text>
  </view>
</view>

```



```css
//miniprogram/components/blog-ctrl/cmp.wxss 
.ctrl{
  display: flex;
  align-items: center;
  background-color: #fff;
  height: 100%;
}

.ctrl-item{
  flex: 1;
  text-align: center;
  color: rgba(40, 47, 60, 0.8);
  font-size: 26rpx;
  height: 60rpx;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
}

.ctrl-item .icon{
  margin-right: 12rpx;
  font-size: 32rpx;
}

.ctrl-item text {
  font-size: 32rpx;
}
```

然后我查看页面，发现icon图标并没有出现，这里我犯了一个之前的错误，组件会屏蔽外界的css样式，这就是[组件样式隔离](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html#%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB) 。所以说全局作用下的iconfont.wxss是作用不到该组件的。我们用外部样式类externalClasses来解决这个问题。👇

对于blog这个页面来说，它是pages路径下的，不是组件，可以直接使用iconfont.css，而且blog-ctrl也是在blog这个页面使用的。

![](https://pic2.zhimg.com/80/v2-6460416e64bb56f7676ef93258e6317f_hd.png)

在引用blog-ctrl的同时，将iconfont.css中的图标对应的样式名传入给组件blog-ctrl。然后blog-ctrl.js种进行注册👇

![](https://pic2.zhimg.com/80/v2-a93c32e709057d98e78251fba37f6a77_hd.png)

之后就可以成功显示出来了👇

![](https://pic1.zhimg.com/80/v2-8fce64ddb2395cd373daae964524e868_hd.png)



#### 点击评论按钮的功能

在点击了评论按钮的时候，会先判断是否已授权，若已授权则可以开始写评论，否则要先授权。

这里blog-ctrl会引用前面封装过的授权组件login，现在json配置种进行引入👇

```json
{
  "component": true,
  "usingComponents": {
    "login-cmp": "/components/login/cmp"
  }
}
```

然后在blog-ctrl.wxml中使用，这里login组件中有一个属性show来规定其自身显示与否，需要调用者传入。所以在使用login组件的时候要传递一个show的值，而这个值也是由blog-ctrl.js进行管理。

![](https://pic4.zhimg.com/80/v2-9d0db556ce7ca6f5e659eb68e7a98627_hd.png)

![](https://pic3.zhimg.com/v2-10fb2fe00abd549e95afe74e0fe9201e_r.jpg)

先清楚授权缓存，然后测试一下👇

![](https://pic4.zhimg.com/80/v2-0e88118e00caade1d743be36c26dd744_hd.png)

这里的“拒绝”和“允许”点击了之后要有一些动作，我们在封装login组件的时候，留下了两个很灵活的事件👇

![](https://pic2.zhimg.com/80/v2-612a3cc04197b408224292ec82ae5b52_hd.png)

![](https://pic3.zhimg.com/80/v2-c322f843b563b2d75a4ab0aa2917bfec_hd.png)

进而可以在/miniprogram/components/blog-ctrl/cmp.js 中进行onLoginsuccess和onLoginfail的编写。

![](https://pic1.zhimg.com/80/v2-271881f9fa45d65b132578224d2f0705_hd.png)

#### 复用底部弹出层实现评论框

这部分进行评论框的实现，这里引用到之前封装好的底部弹出层组件/components/bottom-layer/cmp.wxml 

先在json配置中进行引入，然后使用之👇

![](https://pic1.zhimg.com/80/v2-a27ecd8038a52976abe4a8516eeed4de_hd.png)

同样的底部弹出层的显示与否也与一个属性有关。默认值为false，其值在/miniprogram/components/blog-ctrl/cmp.js 中会随着各种操作而变化。这里不详细记录。



![](https://pic1.zhimg.com/80/v2-0e999f1a323389802aae73acb11e8da7_hd.png)

目前这个底部弹出层还是一片空白，它使用了slot结构，所以我们要进行对其内容的编写👇

```html
<bottom-layer  layerShow="{{layerShow}}">
  <view slot="layer-content">
    <textarea name="content" class="comment-content" 
    placeholder="分享你的评论~" value="{{content}}"
    fixed="true"></textarea>
    <button size="mini" class="send">发布</button>
  </view>
</bottom-layer>

/miniprogram/components/blog-ctrl/cmp.wxml 
```



### 云数据库中1对N关系的三种设计方式

所谓数据库中的1对N关系，举个栗子即一个学生可以选修多门课程，一条博客动态可以对应多张图片、多条评论。

本项目中的博文动态就涉及到这种云数据库1对N的关系。

这里一条博文动态对应着N条评论，根据N的数量级大小可以有三种设计方式：

【一、当N为几个或者二十几个时】：

​	直接在每一条blog的动态数据中保存一个评论数组，里面保存着该blog的所有评论，类似下面的img

​	![](https://pic2.zhimg.com/v2-cd634431d3c6435091dc73fe93f28b81_r.jpg)



【二、当N为几十个时】

这时之前的方法一就不太适合了，可以另外新建一个评论集合comment，其中每条数据都有一个自己的id，而blog每一条动态数据都保存其对应的评论id，通过评论id进一步查找得到评论内容。

即1记录N的信息



【三、当N为成百上千时】

新建评论集合comment，每一条评论数据都保存其对应的动态的id，一条动态想要得到其所有评论，可以根据其动态id来查找所有包含该id的评论。

即N记录1的信息。

本项目采用方法三。





### 评论功能实现

新建一个评论集合blog-comment用以存放所有的评论数据。

在写完评论点击发送按钮时，触发事件，执行js函数onSend

![](https://pic4.zhimg.com/80/v2-9666131e4a23395f28060bab83deb68e_hd.png)

```js
   // components/blog-ctrl/cmp.js
let userInfo = {}
const db = wx.cloud.database()

onInput(event){
      this.setData({
        content: event.detail.value
      })
      // console.log(this.data.content)
    },

    onSend(){

      // 插入数据库
      let content = this.data.content
      if(content.trim()==""){
        wx.showModal({
          title: '评论内容不能为空',
          content: '',
        })
        return
      }

      wx.showLoading({
        title: '评论中',
        mask: true,
      })

      db.collection('blog-comment').add({
        data: {
          content,
          createTime: db.serverDate(),
          blogId: this.properties.blogId,
          nickName: userInfo.nickName,
          avatarUrl: userInfo.avatarUrl
        }
      }).then(res=>{
        wx.hideLoading()
        wx.showToast({
          title: '评论成功',
        })

        // 收起评论框
        this.setData({
          layerShow: false,
          content: ""
        })
      })

      // 推送模板消息
    },
```

这里直接在客户端处将数据存入云数据库中。

接下来完成订阅消息推送功能。



### 订阅消息推送功能

所谓“订阅消息推送”，就是你发送了一条动态。然后有别人评论了该动态，系统会自动微信通知你。这里要用到**云调用功能**。

【云调用】官方文档👉[点击](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/openapi/openapi.html#%E4%BA%91%E8%B0%83%E7%94%A8)

基于云函数，通过云函数去调用服务端的一些开放接口，这些接口包括模板消息推送、生成小程序功能等。

本项目就用到[订阅消息推送](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html)功能。

请注意，小程序模板消息接口将于2020年1月10日下线，开发者可使用[订阅消息功能](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html)

首先要制作一个消息模板👇

在微信公众平台手动配置获取模板 ID：
登录 [https://mp.weixin.qq.com](https://mp.weixin.qq.com/) 获取模板，如果没有合适的模板，可以申请添加新模板，审核通过后可使用。

![intro](https://res.wx.qq.com/wxdoc/dist/assets/img/subscribe-message.b562750a.jpg)

这是我选定的一个模板👇

![](https://pic4.zhimg.com/v2-3f2894d071368e379eab2b4870f5dadf_r.jpg)

模板的ID是最重要的，后面要用到。



新建一个云函数sendMessage，在其目录下新建一个config.json，注意命名必须为config.json，内容如下👇

```json
{
  "permissions": {
    "openapi": [
      "subscribeMessage.send"
    ]
  }
}
```

然后编写sendMessage的index.js：

用到了服务端消息发送接口 [subscribeMessage.send](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html)，这里用的是[云调用的方式](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html#method-cloud)

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
  // const { OPENID } = cloud.getWXContext()
  try {
    const result = await cloud.openapi.subscribeMessage.send ({
      // touser: OPENID,
      touser: event.openid,  // 获取到当前动态发布者的openid，得以对其发送订阅消息
      page: `/pages/blog-comment/blog-comment?blogId=${event.blogId}`,
      data: {
        thing1:{
          value: "您的乐评动态有了新回复"
        },
        thing3: {
          value: event.content  
        }
      },
      templateId: 'Vs66cfna_zW0TP4L53sqxY7d2wV8qLkS6TimIBIkfis'
    })
    console.log(result)
    return result
  } catch (err) {
    console.log(err)
    return err
  }
}

```

接下来在onSend函数中进行改造，实现**获取下发权限**，使用的云调用是消息订阅接口 [wx.requestSubscribeMessage](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html)，然后在评论数据添加到云数据库中后调用云函数sendMessage进行订阅消息推送：

```js
        onSend(){

      // 插入数据库
      let content = this.data.content
      let that = this
      if(content.trim()==""){
        wx.showModal({
          title: '评论内容不能为空',
          content: '',
        })
        return
      }

      wx.showLoading({
        title: '评论中',
        mask: true,
      })

      // 往云数据库中插入评论数据
      db.collection('blog-comment').add({
        data: {
          content,
          createTime: db.serverDate(),
          blogId: that.properties.blogId,
          nickName: userInfo.nickName,
          avatarUrl: userInfo.avatarUrl
        }
      }).then(res => {
        console.log(res)
        // 收起评论框
        that.setData({
          layerShow: false,
          content: ""
        })

        wx.hideLoading()
        wx.showToast({
          title: '评论成功',
        })
      })

      wx.requestSubscribeMessage({
        tmplIds: ['Vs66cfna_zW0TP4L53sqxY7d2wV8qLkS6TimIBIkfis'],
        success(res) {
          console.log(res)
          // 推送模板消息
          wx.cloud.callFunction({
            name: 'sendMessage',
            data: {
              content,
              openid: that.properties.openid,
              blogId: that.properties.blogId
            }
          }).then(res => {
            console.log(res)
          }).catch(err => {
            console.log(err)
          })
         
        },
        fail(err) {
          console.log(err)
        },
        complete(data) {
          console.log(data)
        }
      })


    },
```

这样，当用户允许了订阅消息的推送后，每当别人评论了他的动态，都会收到一条订阅消息。

【有个要注意的点】，若用户无法正常收到别人评论动态的消息通知，时因为用户不允许当前小程序启动”消息订阅“，需要用户手动在小程序的设置中开启”接收订阅消息“。



<img src="https://pic2.zhimg.com/80/v2-4ce3c702544e2d1cb96b33cf22ed3bf3_hd.png" style="width:300px" />



### 博客正文实现

#### 从云数据库获取数据

当我们点击一条博文动态的时候，会跳转到其博客正文，并获取到博客的blogid，根据这个blogid去云数据库请求数据，这个数据包括博文和评论两部分。

但是博文数据是存放在blog集合中，评论是存放在blog-comment集合中，所以需要分别向两个数据库集合发起请求，这里在云函数blog中进行编写👇

```js
  app.router('detail', async (ctx,next)=>{
    let blogId = event.blogId
    // 博文详情查询
    let detail = await blogCollection.where({
      _id: blogId
    }).get().then(res=>{
      return res.data
    })

    // 评论查询
    const countResult = await blogCommentCollection.count()
    const total = countResult.total   // 评论总条数
    let commentList = {
      data: []
    }
    if(total>0){ // 如果又total>0，说明有评论，要进行查询
      // 所有评论总数 / 最大查询量 然后向上取整，即为要查询所有评论要进行的次数
      const batchTimes = Math.ceil(total/MAX_LIMIT) 
      const tasks = []
      for(let i = 0; i<batchTimes; i++){
        let promise = blogCommentCollection.skip(i * MAX_LIMIT)
                      .limit(MAX_LIMIT).where({
                        blogId: blogId
                      }).orderBy('createTime','desc')
                      .get()
        tasks.push(promise)  
      } 
      if(tasks.length>0){
        commentList = (await Promise.all(tasks)).reduce((acc,cur)=>{
          return {
            data: acc.data.concat(cur.data)
          }
        })
      }
    }

    ctx.body={
      commentList,
      detail
    }

  })
```

这里用到了promise.all。

然后blog-comment.js中调用该云函数：

```js
  onLoad: function (options) {
    console.log(options)
    this._getBlogDetail(options.blogId)
  },

  _getBlogDetail(blogId){
    wx.showLoading({
      title: '加载中',
      mask: true
    })

    wx.cloud.callFunction({
      name: 'blog',
      data:{
        $url: 'detail',
        blogId: this.data.blogId
      }
    }).then(res=>{
      wx.hideLoading()
      console.log(res)
       this.setData({
        blog: res.result.detail[0],
        commentList: res.result.commentList.data
      })
    })
  },
```

这时拿到的数据，里面的时间格式不对，需要进行格式化处理。

之前封装过一个格式化时间的工具/miniprogram/utils/formatTime.js ，引用这个工具进行数据的格式化处理：

![](https://pic2.zhimg.com/v2-d6fddc5afa7c1fdc6b36d24a18fef921_r.jpg)

#### 页面渲染

```html
<!--pages/blog-comment/blog-comment.wxml-->
<scroll-view scroll-y="true" class="container">
  <view class="blog-card">
    <blog-card blog="{{blog}}" />
  </view>

  <!-- 评论点赞tab -->
  <view class="tab">
    <view class="tab-item">评论列表</view>
  </view>

  <!-- 评论内容列表 -->
  <view class="comment-list">
    <!-- 评论 -->
    <block wx:for="{{commentList}}" wx:key="_id">
      <view class="comment">
        <view class="comment-title">
          <image class="comment-portrait" src="{{item.avatarUrl}}"></image>
          <text class="comment-nickname">{{item.nickName}}</text>
        </view>
        <view class="comment-content">
        {{item.content}}
        </view>
        <view class="comment-time">{{item.createTime}}</view>
      </view>
    </block>
  </view>
</scroll-view>

<view class="blog-ctrl">
  <blog-ctrl blogId="{{blog._id}}" 
             iconfont="iconfont" 
             icon-pinglun="icon-pinglun" 
             icon-fenxiang="icon-fenxiang" 
             bind:refreshCommentList="_getBlogDetail" />
</view>
```



在正文页也是可以进行评论的，评论发送后，应该重新刷新当前页，这个动作要如果触发呢？

修改blog-ctrl.js中的onSend函数，在评论数据发布成功后，向父级组件调用者发起一个事件，

```js
// 父级刷新评论页面
this.triggerEvent('refreshCommentList')
```

然后又blog-comment进行刷新动作：

```html
<view class="blog-ctrl">
  <blog-ctrl blogId="{{blog._id}}" 
             iconfont="iconfont" 
             icon-pinglun="icon-pinglun" 
             icon-fenxiang="icon-fenxiang"
             bind:refreshCommentList="_getBlogDetail" />
```



#### 博文分享功能

我们要点击分享按钮，然后将博文分享出去。回来看blog-ctrl里的这部分代码：

```html
   <i class="iconfont icon-fenxiang icon"></i>
    <text>分享</text>
```

小程序规定，要想[转发分享](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%BC%95)，必须使用button标签，所以这里要修改。

```html
    <button open-type="share" size="mini" class="share-btn">
      <i class="iconfont icon-fenxiang icon"></i>
      <text>分享</text>
    </button>
```

通过给 `button` 组件设置属性 `open-type="share"`，可以在用户点击按钮后触发 [`Page.onShareAppMessage`](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onshareappmessageobject-object) 事件。



知道怎么触发转发分享事件了，下一步就是要把有用的数据传进去。数据包括blogId和blog item自身

所以在使用blog-ctrl组件的时候，就把这两数据传入：

![](https://pic3.zhimg.com/80/v2-d7bc4a56305c245d3f8295dc50079337_hd.png)

然后blog-ctrl组件接收这两个数据，并在转发按钮处使用：

```html
    <button open-type="share" 
            size="mini" class="share-btn"
            data-blogid="{{blogId}}" data-blog="{{blog}}">
      <i class="iconfont icon-fenxiang icon"></i>
      <text>分享</text>
    </button>
```

然后所在页面就会自动触发onShareAppMessage，打印一下看看参数有没有传到

```js
  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function (event) {
    console.log(event)
  }
```

![](https://pic3.zhimg.com/v2-6cf02cc787fddd8adf44468aa537bd72_r.jpg)

成功触发onShareAppMessage并获得参数数据。

编写onShareAppMessage👇

```js
   /*
   * 用户点击右上角分享
   */
  onShareAppMessage: function (event) {
    console.log(event)
    let blogObj = event.target.dataset.blog
    return {
      title: blogObj.content,
      path: `/pages/blog-comment/blog-comment?blogId=${blogObj._id}`,
      imageUrl: blogObj.img[0] //不写的话默认截图该页面80%， imageUrl支持http图片链接和云文件ID（云文件ID 2019.07新增功能）
    }
  }
```

<img src="https://pic4.zhimg.com/80/v2-99140aeddb475144d20b8f9afe3773fa_hd.png" style="width:300px" />

 

## 7.【我的】功能实现

```
- 对比不同方式获取用户信息的应用场景
- 本地存储播放历史
- 云函数调用云数据库与小程序调用云数据库的差别
- 云调用生成小程序码
```





### 【重要】对比不同方式获取用户信息的应用场景

#### open-data

<https://developers.weixin.qq.com/miniprogram/dev/component/open-data.html>

![](https://pic1.zhimg.com/80/v2-ffbfcdcdbc2d215247aa7995dc08905f_hd.png)

open-data**不需要用户进行授权**，直接就可以显示出来，但是只能在wxml中获取得到，也只能在界面上显示，无法进行js级别的操作。 



#### wx.getUserInfo()

<https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html>

调用前需要 [用户授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html) scope.userInfo。先通过wx.getSetting()查看用户是否已授权。

只有在获得用户授权后才能正常使用wx.getUserInfo()

```
    wx.getSetting({
      success: res=>{
        console.log(res)

        if(res.authSetting['scope.userInfo']){
          // 只有在获得用户授权后才能正常使用wx.getUserInfo()
          wx.getUserInfo({
            success: (res) => {
              console.log(res)
            }
          })
        }

      }
    })
```

![](https://pic4.zhimg.com/v2-08a75c3d6c31c93bd49500dced359477_r.jpg)



#### button触发授权

```html
<button open-type="getUserInfo" bindgetuserinfo="onGotUserInfo">
  点击授权
</button>
```

```js
  onGotUserInfo(event){
    console.log(event)  //得到授权信息
  },
```

![](https://pic2.zhimg.com/80/v2-c3e214959de03cd23cb11e8adfd8c846_hd.png)





#### openid获取

以上的方式都无法获取到openid

传统的获取方法如下：

![](https://pic2.zhimg.com/v2-14a762771b6882073d72917ee56edb51_r.jpg)

code的有效期只有五分钟。

需要前后端协作，比较麻烦。



云开发获取openid方式如下：

![](https://pic2.zhimg.com/v2-5f63f30964fb19da3448326d40c7307d_r.jpg)



```js
  getOpenid(){
    wx.cloud.callFunction({
      name: 'login',
    }).then(res=>{
      console.log(res)
    })
  },
```

得到的res中就包含我们想要的appid和openid。

这里调用了云函数中的login，这个login云函数是系统自带的，要用之前记得先将其上传并部署到云端。



### “我的”页面实现

更新图标，和前面的一样，不赘述。

html结构👇

```html
<view class="profile-header">
  <view class="avatar-url">
    <open-data type="userAvatarUrl"></open-data>
  </view>
  <open-data type="userNickName" class="nickname"></open-data>
</view>

<view class="nav">
  <view class="nav-item">
    <navigator class="content" url="/pages/profile-playhistory/profile-playhistory" hover-class="none">
      <i class="iconfont icon-jilu"></i>
      <text class="text">最近播放</text>
      <i class="iconfont icon-changyongtubiao-xianxingdaochu-zhuanqu-"></i>
    </navigator>
  </view>
  <view class="nav-item">
    <navigator class="content" url="/pages/profile-bloghistory/profile-bloghistory" hover-class="none">
      <i class="iconfont icon-fabu2"></i>
      <text class="text">我的乐评</text>
      <i class="iconfont icon-changyongtubiao-xianxingdaochu-zhuanqu-"></i>
    </navigator>
  </view>
  <view class="nav-item">
    <navigator class="content">
      <i class="iconfont icon-erweima"></i>
      <text class="text">小程序码</text>
      <i class="iconfont icon-changyongtubiao-xianxingdaochu-zhuanqu-"></i>
    </navigator>
  </view>
</view>
```

这里页面跳转没有用以往绑定事件js navigateTo的方法，而是用了一个新标签`navigator`，该标签的url属性填上目标页面的url即可跳转。注意加上`hover-class="none"`，这样可以消除点击时产生的阴影。



在app.json中进行新页面的配置，新增两个新页面：

```
  "pages": [
    "pages/playlist/playlist",
    "pages/blog/blog",
    "pages/profile/profile",
    "pages/demo/demo",
    "pages/musiclist/musiclist",
    "pages/player/player",
    "pages/blog-edit/blog-edit",
    "pages/blog-comment/blog-comment",
    "pages/profile-playhistory/profile-playhistory",
    "pages/profile-bloghistory/profile-bloghistory"
  ],
```



样式的处理中，我要用到背景图，但是小程序中背景不能用本地图片，而要使用https链接图片或者base64格式图片。使用base64的话比起https链接图片，不用去多做网络请求，性能较号，但是base64图片不宜过大。



### 播放历史本地存储实现

播放历史的信息存储一般有两种方法，一种是将播放历史信息存入数据库中，另一种是使用本地存储。这里我采用小程序本地缓存实现。

缓存的key值使用openid，这样可以唯一标识用户。

app.js的onLaunch在小程序一开始就会执行，我们在这里获得openid：

```js
//app.js
App({
  onLaunch: function () {
    
    if (!wx.cloud) {
      console.error('请使用 2.2.3 或以上的基础库以使用云能力')
    } else {
      wx.cloud.init({
        // env 参数说明：
        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源
        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看
        //   如不填则使用默认环境（第一个创建的环境）
        env: 'dev-r049g',
        traceUser: true,  //记录小程序的访问者
      })
    }

    this.globalData = {
      playingMusicId: -1,
      openid: -1,  // 正常用户的openid不会是-1，这里占位用于存储真正的openid
    }  
    this.getOpenid()
  },
  setPlayingMusicId(musicId){
    this.globalData.playingMusicId = musicId
  },
  getPlayingMusicId(){
    return this.globalData.playingMusicId
  },


  getOpenid(){
    console.log(123)
    wx.cloud.callFunction({
      name: 'login'
    }).then(res=>{
      this.globalData.openid = res.result.openid

      if (wx.getStorageSync(this.globalData.openid)==''){
        wx.setStorageSync(this.globalData.openid, []) // 一开始就获得openid作为本地缓存的key，初始时缓存为空数组
      }else{
        // 否则什么都不做
      }

    })
  },
})

```



在音乐播放的js文件player.js中编写savePlayHistory()函数：

```js
// 保存播放历史
savePlayHistory(){
  // 当前正在播放的歌曲
  const music = musiclist[nowPlayingIndex]
  const openid = app.globalData.openid  
  const history = wx.getStorageSync(openid)

  let exist = false // 标志当前歌曲是否已存在于history中，是的话不再重复记录
  for(let i = 0; i < history.length; i++){
    if( history[i].id == music.id ){
      exist = true
      break  // 一旦发现存在就跳出
    }
  }
  if(!exist){
    history.unshift(music)  // 数组头部插入
    wx.setStorageSync(openid, history)
  }
},
```

在歌曲播放的时候调用该函数：

```js
      if(!this.data.isSame){
        backgroundAudioManager.src = result.data[0].url  //歌曲源
        backgroundAudioManager.title = music.name //歌曲名
        backgroundAudioManager.coverImgUrl = music.al.picUrl //歌曲封面
        backgroundAudioManager.singer = music.ar[0].name //歌手名
        backgroundAudioManager.epname = music.al.name //专辑名

        // 保存播放历史
        this.savePlayHistory()
      }
```

这样就成功的将播放过的每首歌的具体信息存入了缓存数组中。



### 播放历史页面实现

先获取本地缓存数据并保存：

```js
  onLoad: function (options) {
    
    const playHistory = wx.getStorageSync(app.globalData.openid)
    if(playHistory.length==0){
      wx.showModal({
        title: '播放历史为空',
        content: '',
      })
    }else{
      this.setData({
        musiclist: playHistory
      })
    }
  },
```

然后调用之前封装过的歌曲列表组件musiclist，将数据传入

```html
<musiclist-cmp musiclist="{{musiclist}}" />
```

看下效果，能正常显示，点击歌曲还能进行播放，一切看起来很棒的样子👇

![](https://pic1.zhimg.com/80/v2-906445acff5286e599c38818a45991ad_hd.png)

但是，当点击下一首播放的时候，是播放的最后一个点开的的歌单列表的下一首歌，而不是当前播放历史里的歌。这个bug是因为缓存中的歌单列表没有修改的原因，那么改它👇

```js
  onLoad: function (options) {
    
    const playHistory = wx.getStorageSync(app.globalData.openid)
    if(playHistory.length==0){
      wx.showModal({
        title: '播放历史为空',
        content: '',
      })
    }else{
      // storage里存储的musiclist替换成播放历史的歌单
      wx.setStorage({
        key: 'musiclist',
        data: playHistory,
      })
      this.setData({
        musiclist: playHistory
      })
    }
  },
```

搞定。



### 我的乐评实现

云函数blog，通过openid从数据库获取所有乐评数据：

```js
  const wxContext = cloud.getWxContext()
  app.router('getListByOpenid', async(ctx, next)=>{
    ctx.body = await blogCollection.where({
      _openid: wxContext.OPENID
    }).skip(event.start).limit(event.count)
    .orderBy('createTime', 'desc').get().then(res=>{
      return res.data
    })
  })
```



调用云函数：

```js
  onLoad: function (options) {
    this._getListByCloudFn()
  },

  _getListByCloudFn(){
    wx.showLoading({
      title: '加载中',
    })
    wx.cloud.callFunction({
      name: 'blog',
      data: {
        $url: 'getListByOpenid',
        start: this.data.blogList.length,
        count: 10
      }
    }).then(res=>{
      this.setData({
        blogList: this.data.blogList.concat(res.result) 
      })
      wx.hideLoading()
    })
  },
```



接下来进行页面的布局和渲染，引入之前封装过的blog-card组件和blog-ctrl组件，

```html
<view>
  <block wx:for="{{blogList}}" wx:key="_id">
    <view class="blog-panel">
      <blog-card blog="{{item}}"
                 bindtap="goComment"
                 data-blogid="{{item._id}}"></blog-card>
      <blog-ctrl blogId="{{item._id}}"
                 blog="{{item}}"
                 iconfont="iconfont"
                 icon-pinglun="icon-pinglun"
                 icon-fenxiang="icon-fenxiang"></blog-ctrl>
    </view>
  
  </block>
</view>

```

js部分：

```js
// pages/profile-bloghistory/profile-bloghistory.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    blogList: []
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    this._getListByCloudFn()
  },

  _getListByCloudFn(){
    wx.showLoading({
      title: '加载中',
    })
    wx.cloud.callFunction({
      name: 'blog',
      data: {
        $url: 'getListByOpenid',
        start: this.data.blogList.length,
        count: 10
      }
    }).then(res=>{
      this.setData({
        blogList: this.data.blogList.concat(res.result) 
      })
      wx.hideLoading()
    })
  },

  goComment(event) {
    console.log(event)
    wx.navigateTo({
      url: '../../pages/blog-comment/blog-comment?blogId=' + event.target.dataset.blogid,
    })
  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {

  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {

  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {

  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {

  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    this.setData({
      blogList: []
    })

    this._getListByCloudFn()
    wx.stopPullDownRefresh()
  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    this._getListByCloudFn()
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function (event) {
    console.log(event)
    let blogObj = event.target.dataset.blog
    return {
      title: blogObj.content,
      path: `/pages/blog-comment/blog-comment?blogId=${blogObj._id}`,
      imageUrl: blogObj.img[0]
    }
  }
})
```

搞定。

### 云调用生成小程序码

官方文档：<https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html>

云调用生成小程序码：<https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html#method-cloud>

先新建一个云函数getQrCode用于专门负责胜场小程序码，因为要使用云调用，和之前使用订阅消息功能一样，都要在云函数中新建多一个配置文件`config.json`，需在 `config.json` 中配置  `wxacode.getUnlimited` API 的权限：

```json
{
  "permissions": {
    "openapi": [
      "wxacode.getUnlimited"
    ]
  }
}
```



```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
  const wxContext = cloud.getWXContext()

  const result = await cloud.openapi.wxacode.getUnlimited({
    scene: wxContext.OPENID  //这云函数里参数最后一项还不能有逗号，我踩过这种坑。
  })
  // console.log(result) 
  const upload = await cloud.uploadFile({
    cloudPath: 'qrcode/' + Date.now() + '_' + Math.random() + '.png',
    fileContent: result.buffer
  })

  return upload.fileID
}
```

cloud.openapi.wxacode.getUnlimited()调用产生的结果中的buffer是我们想要的小程序码资源，但是是buffer格式，无法直接使用，所以将其以图片png格式存进云存储中，生成对应的file ID，这样就可以识别为图片了。

```js
  onTapQrCode(){
    wx.showLoading({
      title: '生成中',
    })
    wx.cloud.callFunction({
      name: 'getQrCode'
    }).then(res=>{
      console.log(res)
      const fileId = res.result
      wx.previewImage({
        urls: [fileId],
        current: fileId
      })

      wx.hideLoading()
    })
  },
```

通过一个预览图片的功能显示小程序码。

![](https://pic1.zhimg.com/v2-bac9efed9a3b6820439c8ccd87329c6c_b.webp)

## 8.小程序高级知识

```
- 小程序渲染层与逻辑层交互原理
- 小程序运行机制与更新机制
- 小程序性能与体验优化
- 小程序上线审核流程
- 小程序场景值的应用
```

### 小程序渲染层和逻辑层的原理

![](https://pic4.zhimg.com/v2-1f7f0cc4206ee5619409c8aacaa047af_r.jpg)

渲染层即处理页面显示的，对应的是HTML和CSS；逻辑层是处理页面JS逻辑的。网页程序的渲染层和逻辑层是互斥的，渲染引擎和JS引擎都在一个单线程里。当渲染引擎正在工作渲染页面的时候，JS脚本是不会执行的，而当脚本执行的时候页同样不会渲染界面。所以当JS脚本要进行大量的计算的时候，可能会使得页面失去响应。但是在**小程序中，渲染层和逻辑层是分开的，它们分别运行在不同的线程当中。**

![](https://pic1.zhimg.com/v2-9c93be298bbfc9b0b8377e172fc94b6c_r.jpg)



小程序本质上也是一个Hybrid程序。

![](https://pic4.zhimg.com/v2-d8394edf0838de302b86626afb443ce7_b.png)

Native系统层内有一个JSBridge，通过他可以实现对底层API接口的调用，如微信的定位、扫码、离线存储、网络请求、微信步数等等。而小程序渲染层和逻辑层的交互，不是直接交互的，而是通过一个中间层Native系统层来实现的。

所以小程序最好不要进行频繁的setData()，因为这会频繁的触发渲染层、系统层、逻辑层之间的数据传递，对性能是个很不好的影响。另外，那些不需要显示在页面中的数据不要放在data中，而是用变量存储即可，如果这种不需要要显示在页面的数据都放在data中，那么修改它的时候又要进行无谓的setData操作，没必要，很消耗资源。



### 小程序的运行机制

- 冷启动：之前没打开过该小程序，这时打开的话就叫冷启动。另外，该小程序有启动过，但是被人为主动销毁了，再    打开也是冷启动。
- 热启动：之前打开过小程序，在一定时间内(一般是五分钟)再次打开，就是热启动。
- 前台和后台：前台就是小程序显示着就是前台的状态，当手机按home键或者按小程序右上角关闭按钮的时候，小程序就切换到后台了。微信开发者工具里也有“切后台”、“切前台”的功能。
- 小程序销毁：小程序被切后台之后并没有立即销毁，一般会运行一段时间(一般是五分钟)之后才真正销毁。可以人工销毁。



### 小程序的更新机制

在app.js中进行小程序更新操作，在每次onLaunch的时候就执行下列函数：

```js
  checkUpdate(){
    const updateManager = wx.getUpdateManager()
    // 检测版本更新
    updateManager.onCheckForUpdate(res=>{
      if(res.hasUpdate){
        updateManager.onUpdateReady(()=>{
          wx.showModal({
            title: '更新提示',
            content: '当前有新版本，是否重启',
            success(res){
              if(res.confirm){
                updateManager.applyUpdate()
              }
            }
          })
        })
      }
    })
  },
```

可以在微信开发者工具中进行模拟👇

![](https://pic2.zhimg.com/v2-46c1ad769fb4072a6f9eea402584d7d5_r.jpg)



![](https://pic1.zhimg.com/80/v2-c610b71649f66c6eb855d8b0495d25a4_hd.jpg)



### 小程序性能与体验优化

- 合理设置可点击元素的响应区域的大小，常见的扩大方法是设置padding
- 避免渲染页面耗时过长
- 避免执行脚本的时间过长，检查脚本的逻辑是否有问题，进行优化
- 对网络的请求做必要的缓存以避免多余的请求
- 不要引用未被使用的wxss样式，减少程序包大小
- 所有资源请求建议都使用HTTPS，比起明文传输的HTTP更加安全
- 不使用废弃接口
- 避免过大的WXML节点数目：
  - 一个页面少于1000个WXML节点
  - 节点树深度少于30层
  - 子节点树不大于60个
- 及时回收定时器
- 避免使用`:active`伪类来实现点击态，改用`hover-class`
-  滚动区域可开启惯性滚动以优化用户体验
  - 安卓机自带惯性滚动效果
  - IOS：要手动设置 -webkit-overflow-scrolling:touch 的样式
- 所有请求的耗时不应太久，另外加上showloading的效果
- 避免短时间内发起太多图片请求，小图标不要用图片，用iconfont等字体图标
- 避免在短时间内发起太多请求
- setData
  - setData数据不宜过大，最大1M。太大的话渲染层、逻辑层、系统层间的交互负担重 
  - 避免频繁的调用setData
  - 不用于绑定显示在wxml上的数据不要存于data，从而不用调用setData



#### 性能评分

点开微信开发者工具调试器里有Audits，然后手动点击各个页面，会自动进行评分。

![](https://pic2.zhimg.com/v2-03e2cf0f649eaca45b8625aeb8f7d385_b.png)



### 详解setData工作原理

#### 异步与同步

官网文档：<https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#Page.prototype.setData(Object%20data,%20Function%20callback)>

`setData` 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 `this.data` 的值（同步）。这句话得理解一下。

![](https://pic4.zhimg.com/v2-d8394edf0838de302b86626afb443ce7_r.jpg)

使用setData的时候，逻辑层修改了数据之后，将数据传给系统层，同时改变对应的 `this.data` 的值（同步）；系统层再传给渲染层，这个过程是（异步）的过程。

![](https://pic2.zhimg.com/v2-b5926677b7f9a34035919a288ade4a6d_r.jpg)

从上图也可以看到，setData中的回调函数也是一个异步的操作，它会等下面的js代码执行完成之后才执行回调函数。



#### 修改对象里的值

对于data中的对象类型的数据，如果要修改其数据，不能将整个对象数据都改了，但是注意，以下这样做是错的：

```
  onChange(){
    this.setData({
      testObj.age: 6
    })
  },
```

要用方括号和引号包裹起来才是正确的👇

```js
  onChange(){
    this.setData({
      ['testObj.age']: 6
    })
  },
```

另外，setData中的数据可以是新数据，可以不用事先在data中定义好。



### 场景值sence及其应用场景

官网👉<https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/scene.html>

场景值用来描述用户进入小程序的路径。完整场景值的含义请查看[场景值列表](https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html)。

可以在 `App` 的 `onLaunch` 和 `onShow`，或[wx.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 中获取到场景值

![](https://pic1.zhimg.com/80/v2-8d65af69b420a16851553c6daea83c11_hd.png)

![](https://pic2.zhimg.com/80/v2-285855b5fa7718e365f3fb8df1d5f59c_hd.png)

![](https://pic4.zhimg.com/80/v2-64ca333e81f24bd7af49d23094ca1efb_hd.jpg)

我们可以在开发者工具中切前台和前后台来模拟各种场景值👇

![](https://pic1.zhimg.com/80/v2-a5bab23bec95f04251a794c611e6433e_hd.png)



我们可以通过场景值来了解到用户的来源，并进行进一步的逻辑操作，或者用于用户分析，这对于运营是一个很重要的点。

### 页面收录sitemap.json

感觉不是太主要，不做笔记了。



## 9.后台管理系统

```
- 前后端分离架构的后台管理系统
- vue-admin-template构建管理系统前端
- Koa2构建管理系统后端
- HTTP API访问云开发资源
```

### 项目架构：

​		**前后端分离**

![](https://pic2.zhimg.com/80/v2-1089ff56600d4f7148699f7804c92b12_hd.png)



### vue-admin-template构建前端部分

 [vue-admin-template](https://github.com/PanJiaChen/vue-admin-template)是[vue-element-admin](http://panjiachen.github.io/vue-element-admin)的基础模板，本项目只用vue-admin-template就行了。

```js
# 克隆项目
git clone https://github.com/PanJiaChen/vue-admin-template.git

# 进入项目目录
cd vue-admin-template

# 安装依赖
npm install

# 建议不要直接使用 cnpm 安装以来，会有各种诡异的 bug。可以通过如下操作解决 npm 下载速度慢的问题
npm install --registry=https://registry.npm.taobao.org

# 启动服务
npm run dev
```

将src/views中多余的文件夹删去，只留下login和404；之后新建需要的文件夹和文件👇

![](https://pic3.zhimg.com/80/v2-47acc78651f2db33d40f010d1aabab60_hd.png)

这里就包含了需要管理的博客管理、歌单管理、轮播图管理。然后进行router的路由配置。详见\src\router\index.js。

路由配置好之后就可以进行前端页面的编写了。

![](https://pic3.zhimg.com/80/v2-1f4eb447af112720bc5f69bcee4f1443_hd.png)



### Koa2构建管理系统后端

新建admin-backend文件夹，然后`npm init`进行项目初始化。

接着`npm i koa`安装koa。

新建app.js文件并编写如下代码👇

```js
const Koa = require('koa')
const app = new Koa()

app.use(async (ctx) => {
    ctx.body = `<h1>你好！</h1>
                <h2>欢迎使用koa！</h2>`
})

app.listen(3000, () => {
    console.log('服务已启动')
})
```

然后在命令行输入`node app.js`就可以启动服务器了，在<http://localhost:3000/>就可以看到内容了👇

![](https://pic1.zhimg.com/80/v2-56535c5a922dde22a6c701589cf2422c_hd.png)

这样就用node+koa搭建起了一个简易的服务器了。





### access-token的缓存和更新

官网文档：<https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html>

access_token是接口调用凭证。当我们通过HTTP API这种方式调用接口的时候都要用到这个参数。我们需要对access_token进行相应的缓存和更新。

我们在后端中要对https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET发起http请求，这里我使用request和request-promise来发送请求。

先安装之    `npm install request`、 `npm install request-promise`

然后编写一个专门的工具js文件来用于发送请求👇

![](https://pic4.zhimg.com/80/v2-2e6de796a3a090bea04244c453311aad_hd.png)

命令行`node utils/getAccessToken.js`执行之，可以看到成功的返回了access_token的信息👇

![](https://pic3.zhimg.com/80/v2-68f416e8a521ce1476e0c01d6f4221bf_hd.png)

获得token之后就要保存好它，我将其写入一个json文件中：

![](https://pic2.zhimg.com/v2-a04b14661a9794e343871333a537a495_r.jpg)



编写读取`access_token.json`文件的方法👇

```js
const getAccessToken = async () => {
    // 读取文件
    // const readRes = fs.readFileSync(fileName)  //如果不加 'utf8'，得到的是Buffer
    const readRes = fs.readFileSync(fileName, 'utf8')  //加上 'utf8'，得到字符串格式
    // console.log(readRes)
    const readObj = JSON.parse(readRes)
    console.log(readObj)

}

getAccessToken()
```

如果`access_token.json`文件存在的话是可以正常获取到的，但是当`access_token.json`文件一开始不存在的话，这样就会报错了，而nodejs是单线程的，所以必须要用try catch来处理👇

```js
const getAccessToken = async () => {
    // 读取文件
    try {
        const readRes = fs.readFileSync(fileName, 'utf8')  //加上 'utf8'，得到字符串格式
        const readObj = JSON.parse(readRes)

        return readObj.access_token
    } catch (error) {
        await updateAccessToken()  // 该文件不存在所以要重新发送请求并写入文件
        await getAccessToken()  // 读取文件
    }

}
```

token的有效期是2小时，也就是7200秒，所以我们需要每隔一定的时间发送请求更新token：

```js
// 定时更新token
setInterval(async () => {
    await updateAccessToken()
}, (7200 - 300) * 1000);  // token有效期是2小时也就是7200秒，我提前5分钟也就是300秒去更新

```

当我们关闭服务器或者因为服务器宕机了，再次开启的时候，用的还是老的token，很可能已经过期了，所以需要拿token文件中的创建时间和当前时间对比，若超过2小时，就要重新请求token。

```js
const rp = require('request-promise')
const fs = require('fs')
const path = require('path')
const fileName = path.resolve(__dirname, './access_token.json')

const APPID = '你的appid'
const APPSECRET = '你的secret'
const URL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`

const updateAccessToken = async () => {
    const resStr = await rp(URL)  // 返回结果是一个字符串格式的，需要json.pares转化为json格式
    const res = JSON.parse(resStr)
    console.log(res)

    // 写文件
    if (res.access_token) {
        fs.writeFileSync(fileName, JSON.stringify({
            access_token: res.access_token,
            createTime: new Date()
        }))
    } else {
        // 当无法正确获取到access_token的时候要再次调用本方法
        await updateAccessToken()
    }
}

const getAccessToken = async () => {
    // 读取文件
    try {
        // const readRes = fs.readFileSync(fileName)  //如果不加 'utf8'，得到的是Buffer
        const readRes = fs.readFileSync(fileName, 'utf8')  //加上 'utf8'，得到字符串格式
        // console.log(readRes)
        const readObj = JSON.parse(readRes)
        // console.log(readObj)

        const createTime = new Date(readObj.createTime).getTime()
        const nowTime = new Date().getTime()
        if ((nowTime - createTime) / 1000 / 60 / 60 >= 2) {
            await updateAccessToken()  // 由于服务器宕机关闭等原因导致token过期没有及时更新，所以要重新发送请求并写入文件
            await getAccessToken()  // 读取文件
        }

        return readObj.access_token
    } catch (error) {
        await updateAccessToken()  // 该文件不存在所以要重新发送请求并写入文件
        await getAccessToken()  // 读取文件
    }

}

// 定时更新token
setInterval(async () => {
    await updateAccessToken()
}, (7200 - 300) * 1000);  // token有效期是2小时也就是7200秒，我提前5分钟也就是300秒去更新

module.exports = getAccessToken //模块导出
```



### MVC模式

*MVC*全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。

对于我们的项目，M层(model)一般是和数据库和数据相关的。V层(view)一般就是前端显示的部分。C层(controller相当于M层和V层之间的纽带,主要用于控制跳转、处理业务逻辑。

我在项目中新建了一个文件夹controller，代表C层。我会把前端请求都发送到controller，然后通过controller去调用云开发里的内容，然后把结果返回到前端去展示。

controller文件夹下新建一个playlist.js，我把所有关于歌单处理的业务都放在这里。



### 路由初探

首先我们需要路由管理，先来`npm i koa-router`安装一下koa-router。

**controller/playlist.js：**

```js
const Router = require('koa-router')
const router = new Router()

router.get('/list', async (ctx, next) => {
    // 查询歌单列表
    ctx.body = '歌单列表'
})

module.exports = router  //作为一个模块导出
```



在app.js中引用上述定义好的路由：

![](https://pic2.zhimg.com/v2-bc5f3531b4459db3a52901be4a91278d_r.jpg)

`node app`启动服务器，然后在访问<http://localhost:3000/playlist/list>就可以看到该路由成功跳转并显示👇

![](https://pic1.zhimg.com/80/v2-9907492c8de8f3464a8001f8ce7f219c_hd.png)

那么接下来只要在该路由下，调用小程序云开发的HTTP API获取到数据。

### HTTP API 触发云函数获取歌单列表

这里我们要在后端代码中调用本小程序云函数中的music云函数，其中就包含了获取歌单列表数据的方法，如下图所示👇

![](https://pic3.zhimg.com/v2-1d5552c2e71f6e0ecacae975a1068a32_r.jpg)

那么要如何在后端代码中触发小程序云函数？

官网文档：<https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-http-api/functions/invokeCloudFunction.html>

需要对下面这个请求网址发送post请求。

【请求地址】

```text
POST https://api.weixin.qq.com/tcb/invokecloudfunction?access_token=ACCESS_TOKEN&env=ENV&name=FUNCTION_NAME
```

注意这里的三个参数access_token、env、name。

```js
const Router = require('koa-router')
const router = new Router()
const rp = require('request-promise')
const getAccessToken = require('..//utils/getAccessToken')

const ENV = 'dev-r049g'  // 我的小程序云环境id

router.get('/list', async (ctx, next) => {
    // 查询歌单列表
    const access_token = await getAccessToken() // getAccessToken是异步操作要加上await
    // console.log('access_token是' + access_token);

    const url = `https://api.weixin.qq.com/tcb/invokecloudfunction?access_token=${access_token}&env=${ENV}&name=music`

    let options = {
        method: 'POST',
        uri: url,
        body: {
            $url: 'playlist',
            start: 0,
            count: 50
        },
        json: true // Automatically stringifies the body to JSON
    }
    const data = await rp(options)
        .then((res) => {
            // console.log(res);
            return JSON.parse(res.resp_data).data
        }).catch((err) => {
            console.log('POST failed...');
        })

    ctx.body = {
        data,
        code: 20000 // 前端request方法要求了返回结果有code: 20000才算返回成功，所以要加上code: 20000
    }


    // ctx.body = '歌单列表'
})

module.exports = router  //作为一个模块导出
```

重启服务器app.js，然后访问<http://localhost:3000/playlist/list>，可以看到数据成功获取到了👇

![](https://pic1.zhimg.com/v2-7c82b2e35f38460b5336d79fd8736d04_r.jpg)







### 歌单列表前后端交互与跨域问题

后端接口已经完成，回到前端部分，我需要在前端部分向这个后端接口发起Ajax请求。这里vue-admin-template项目里封装好了一个axios的工具request.js，我直接用这个request.js来发送请求。

vue-admin-template/src/api/playlist.js：

```js
import request from '../utils/request'

const baseURL = 'http://localhost:3000'

export function fetchList(params) {
    return request({
        params,
        url: `${baseURL}/playlist/list`,
        method: 'get'
    })
}

```

接着在list.vue中调用上述方法进行发送Ajax请求：

```js
<script>
import { fetchList } from "@/api/playlist";
export default {
  data() {
    return {
      playlist: [],
      count: 50
    };
  },

  created() {
    this.getList();
  },

  methods: {
    getList() {
      fetchList({
        start: this.playlist.length,
        count: this.count
      })
        .then(res => {
          console.log(res);
        })
        .catch(err => {
          console.log("ERROR");
        });
    }
  }
};
</script>
```

然后我们启动后端服务器和前端项目，访问<http://localhost:9528/#/playlist/list>的时候发生了网络错误，控制台显示存在**跨域问题**，如下图所示。因为<http://localhost:9528/#/playlist/list>和后端接口urlhttp://localhost:3000/playlist/list?start=0&count=50域名不一致，违反了同源策略。

![](https://pic2.zhimg.com/v2-286322a828af2b11c69aaddcd23ccec5_r.jpg)

那么我就在后端部分设置允许其跨域，用到了**koa2-cors**。

回到后端项目，`npm i koa2-cors`安装koa2-cors。然后使用它👇

```js
const cors = require('koa2-cors')

// 跨域
app.use(cors({
    origin: ['http://localhost:9528'], // 数组，里面存放允许访问本后端项目的前端url
    credentials: true  // 证书设为true，表示允许
}))
```

重启服务，发现跨域的问题就解决了，并成功返回了数据👇

![](https://pic2.zhimg.com/v2-657ea7dbbc5d038701e3f2d87e42b4fd_r.jpg)

前端成功获取到数据后就好办了。

vue-admin-template中内置了element-ui，就直接用element-ui来做好了。







。